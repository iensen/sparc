/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Sparc.jj */
/*@egen*///TODO: change extendedNonRelAtom to extendedAtom.
options{  BUILD_PARSER = true;  STATIC = false;  OUTPUT_DIRECTORY = "/home/iensen/sparc_project/SparcTranslator/parser";               }PARSER_BEGIN(SparcTranslator)package parser;import java.io.*;import sorts.*;import java.util.HashMap;import java.util.ArrayList;import java.util.List;import java.util.HashSet;import java.util.Scanner;import java.util.Arrays;import java.util.Set;import translating.Translator;import typechecking.TypeChecker;import translating.InstanceGenerator;import com.beust.jcommander.Parameter;import com.beust.jcommander.JCommander;import com.beust.jcommander.ParameterException;import querying.QueryEngine;import querying.parsing.AnswerSets.AnswerSetParser;import querying.parsing.AnswerSets.ClingoAnswerSetParser;import querying.parsing.AnswerSets.DLVAnswerSetParser;import configuration.ASPSolver;import externaltools.ClingoSolver;import externaltools.DLVSolver;import externaltools.ExternalSolver;import configuration.Settings;class Arguments{  @ Parameter(description = "Input files") List < String > inputFiles = new ArrayList < String > ();  @ Parameter(names = "-wasp", description = "Generate ASP debugging rules") boolean generateASPWarnings = false;  @ Parameter(names = "-wcon", description = "Generate warnings based on translation to clingcon") boolean generateClingconWarnings = false;  @ Parameter(names =  {    "-Help", "-H", "-help", "--Help", "--help", "-h"  }  , help = true) boolean help;  @ Parameter(names = "-o", description = "Output file") String outputFile = null;  @ Parameter(names = "-A", description = "outputAnswerSets") boolean outputAnswerSets = false;  @ Parameter(names = "-solver", description = "selected solver") String solver = null;  @ Parameter(names = "-solveropts", description = "options passed to internal solver")   String solverOpts = null;}class Pair{  SimpleNode first;  boolean second;  public Pair(SimpleNode first, boolean second)  {    this.first = first;    this.second = second;  }}@ SuppressWarnings("all") public class SparcTranslator/*@bgen(jjtree)*/implements SparcTranslatorTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected JJTSparcTranslatorState jjtree = new JJTSparcTranslatorState();

/*@egen*/  // mapping from sort names to sort expressions assigned to the sorts
  public HashMap < String, ASTsortExpression > sortNameToExpression;  // mapping from predicate names to a list of names of sorts describing
  // arguments
  public HashMap < String, ArrayList < String >> predicateArgumentSorts;  // labels of cr-rules
  public HashSet < String > crRuleLabels;  //sort occurred explicitly in the program
  public HashSet < String > generatingSorts;  // mapping from constant names to their values.
  public HashMap < String, Long > constantsMapping;  // warnings found during the translation
  private ArrayList < String > warnings;  // set of all terms occurring in curly brackets and their subterms
  public HashSet < String > curlyBracketTerms;  // set of all defined record names:
  public HashSet < String > definedRecordNames;  boolean inHead = false;
  int anonSortId = 0;  /**
  * Remove from args all 
  */  private static HashSet < String > fetchOptions(String [] args)  {    HashSet < String > options = new HashSet < String > ();    for (int i = 0; i < args.length; i++)    {      if (args [i].startsWith("--"))      {        options.add(args [i]);        args = ArrayUtils.removeNthElement(args, i);        i--;      }    }    return options;  }  private static final Set < String > supportedSolvers = new HashSet < String > (Arrays.asList("clingo", "dlv"));  public static void main(String [] args)  {    System.err.println("SPARC  V2.44");
       Arguments jArguments = new Arguments();    try    {      new JCommander(jArguments, args);    }    catch (ParameterException ex)    {      System.err.println("ERROR: " + ex.getMessage());      return;    }    if (jArguments.help)    {      show_usage();      return;    }
    if(!jArguments.outputAnswerSets && jArguments.solverOpts != null &&
    (jArguments.solverOpts.indexOf("filter=") !=-1 || jArguments.solverOpts.indexOf("-n=") !=-1 ||
       jArguments.solverOpts.matches("\\s\\d+\\s")))       {           System.err.println("ERROR: Some of the solver arguments from the list \""+jArguments.solverOpts+ "\" \ncan change"+
           " or filter the computed answer sets. Either remove them or\nuse the argument -A to let SPARC compute the answer sets.");
           return;
       }        if (jArguments.solver != null)    {      if (!supportedSolvers.contains(jArguments.solver))      {        System.err.println("Unknown solver: " + jArguments.solver);        return;      }    }    if (jArguments.solver != null && jArguments.solver.equals("clingo"))    {      Settings.getSingletonInstance().setSolver(ASPSolver.Clingo);    }    if (jArguments.solverOpts != null)    {      Settings.getSingletonInstance().setOptions(jArguments.solverOpts);    }    Reader sr = null;    Writer out = null;    if (jArguments.outputFile != null)    {      if (new File(jArguments.outputFile).exists() && !new File(jArguments.outputFile).isDirectory())      {        System.err.println("the output file already exists , do you want to overwrite it? y/n:");        char rep;        try        {
          InputStreamReader converter = new InputStreamReader(System.in);
		  BufferedReader in = new BufferedReader(converter);          rep =in.readLine().charAt(0);         }        catch (IOException e)        {          e.printStackTrace();          return;        }        if (rep != 'y' && rep != 'Y')        {          return;        }      }      try      {        out = new FileWriter(jArguments.outputFile);      }      catch (IOException e)      {        e.printStackTrace();      }    }    TypeChecker tc = null;    StringBuilder translatedProgram = new StringBuilder();    try    {      if (jArguments.inputFiles != null && jArguments.inputFiles.size() != 0)      {        if (jArguments.inputFiles.size() > 1)        {          System.err.println("ERROR: multiple input files");          return;        }        try        {          sr = new FileReader(jArguments.inputFiles.get(0));        }        catch (FileNotFoundException fileException)        {          System.err.println("%INPUT FILE ERROR: " + fileException.getMessage());          return;        }      }      if (sr == null) sr = new InputStreamReader(System.in);      SparcTranslator p = new SparcTranslator(sr);      SimpleNode programTree = p.program();      //process regular expression
      InstanceGenerator gen = new InstanceGenerator(p.sortNameToExpression);      tc = new TypeChecker(p.sortNameToExpression, p.predicateArgumentSorts, p.constantsMapping, p.curlyBracketTerms, p.definedRecordNames, gen);      Translator tr = new Translator(out, p, gen, jArguments.generateASPWarnings, jArguments.generateClingconWarnings);      // do typechecking of rules in the first file
      if (jArguments.inputFiles.size() != 0)      {
        String fileName=getShortFileName(jArguments.inputFiles.get(0));
        tr.setInputFileName(fileName);        tc.setInputFileName(fileName);      }
      if(programTree.jjtGetNumChildren() >2)//if program is not empty      {        tc.checkRules((ASTprogramRules) programTree.jjtGetChild(2));        translatedProgram.append(tr.translateProgram((ASTprogram) programTree, p.generatingSorts, true));
      }
      if(jArguments.outputFile != null)
      {
        tr.writeTranslatedProgram();
      }    }    catch (ParseException pe)    {      System.err.println(pe.getMessage());      return;    }
     System.err.println("program translated");    ExternalSolver solver = null;    AnswerSetParser aParser = null;    try    {      if (Settings.getSolver() == ASPSolver.DLV)      {        solver = new DLVSolver(translatedProgram.toString());        aParser = new DLVAnswerSetParser();      }      else      {        solver = new ClingoSolver(translatedProgram.toString());        aParser = new ClingoAnswerSetParser();      }    }    catch (    FileNotFoundException ex)    {      System.err.println(ex.getMessage());    }    if (jArguments.outputAnswerSets)    {      System.out.println(solver.run(true));    }    else    {      QueryEngine qe = new QueryEngine(aParser.getAnswerSets(solver.run(true)), tc);      qe.run();    }  }  private boolean isInteger(String s)  {
    if(s.length()< 1)
              return false;    if (s.length() == 1 && s.charAt(0) == '0') return true;    if (s.charAt(0) == '0') return false;    for (int i = 0; i < s.length(); i++)    {      if (!Character.isDigit(s.charAt(i))) return false;    }    return true;  }  /**
  * @return absolute path.
  */  private static String getShortFileName(String fullPath)  {    File file = new File(fullPath);    return file.getName();  }  static final String newLine = System.getProperty("line.separator");  /**
  * Output help message
  */  private static void show_usage()  {    System.err.println("usage: sparc filename {options}");    System.err.println(newLine + "Options:" + newLine);    String message = "-A" + newLine +     "    " + newLine +     "  Compute answer sets of the loaded program." + newLine +     newLine +     "-wcon" + newLine +     "    " + newLine +     "  Show warnings determined by CLP-based algorithm. See type warnings section in the manual." +     newLine +     "-wasp" + newLine +     "    " + newLine +     "  Show warnings determined by ASP-based algorithm. See type warnings section in the manual." + newLine +     newLine +     "-solver arg" + newLine +     newLine +     "  Specify the solver which will be used for computing answer sets. arg can have two possible values: dlv and clingo. "     + newLine +     "-solveropts arg" + newLine +     newLine +     "  Pass command line arguments to the ASP solver (DLV or Clingo)." + newLine +     "  " + newLine +     "  Example: -solveropts '-pfilter=p'." + newLine +     newLine +     newLine +     "  For the complete list of dlv options, see " + newLine +     "  http://www.dlvsystem.com/html/DLV_User_Manual.html " + newLine +     newLine +     newLine +     "  For the complete list of clingo options, see " + newLine +     "  http://sourceforge.net/projects/potassco/files/potassco_guide/" + newLine +     newLine +     "  Note that options '0' and '--shift' are passed to clingo solver by default." + newLine +     newLine +     "-Help, -H, -help, --Help, --help, -h" + newLine +     newLine +     "  Show help message." + newLine +     newLine +     "-o arg" + newLine +     newLine +     "  Specify the output file where the translated ASP program will be written. arg is the path to the output file." + newLine +     "  Note that if the option is not specified, the translated ASP program will not be stored anywhere." + newLine +     newLine +     "input_file " + newLine + newLine +     "  Specify the file where the sparc program is located";    System.err.println(message);  }  /**
  * Add built-in sorts to sort expressions
  */  public void addBuiltInSorts()  {    HashMap < String, ASTsortExpression > builtInSorts = BuiltIn.getBuiltInSorts();    for (String sortName : builtInSorts.keySet())    {      sortNameToExpression.put(sortName, builtInSorts.get(sortName));    }  }  /**
  * Add warning to set of warnings
  */  public void addWarning(String warning)  {    warnings.add(warning);  }  public ArrayList < String > getWarnings()  {    return warnings;  }}PARSER_END(SparcTranslator)< DEFAULT, IN_PROGRAM_RULES >TOKEN :{  < MAXINTDIRECTIVE : "#maxint" >| < CONSTDIRECTIVE : "#const" >| < SORTDEFKEYWORD : "sorts" ([ "\r", "\t", " ", "\n" ])+ >| < PREDDEFKEYWORD : "predicates" ([ "\r", "\t", " ", "\n" ])+ >| < PROGRULDEFKEYWORD : "rules" ([ "\r", "\t", " ", "\n" ])+ > : IN_PROGRAM_RULES| < NOT : "not" ([ "\t", "\r", " " ])+ >| < NOTOP : "not" ([ "\t", "\r", " " ])* "(" >| < OR : "or" >| < AND : "and" >| < IDENTIFIER : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >| < VARIABLE :    (      [ "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])*    | "_"    ) >| < NONZERODIGIT : [ "1"-"9" ] >| < POSITIVE_INTEGER :    < NONZERODIGIT >    (      < ZERO >    | < NONZERODIGIT >    )* >| < ZERO : "0" >| < PLUS : "+" >| < MULT : "*" >| < DIV : "/" >| < EQ : "=" >| < EQR : "==" >| < NOTEQ : "!=" >| < GT : ">" >| < GTEQ : ">=" >| < SM : "<" >| < SMEQ : "<=" >| < OP : "(" >| < CP : ")" >| < OB : "{" >| < CB : "}" >| < ORRSEP : ":-" >| < CRRSEP : ":+" >| < WEAKSEP : ":~" >| < COMMA : "," >| < DOT : "." >| < COLON : ":" >| < SEMICOLON : ";" >| < DOLLAR : "$" >| < COMPLEMENT : "~" >| < HEAD_OR : "|" >| < AGGREGATE_COUNT_OB : "#count"([ "\t", "\r", "\n"," " ])* "{" >| < AGGREGATE_SUM_OB : "#sum"([ "\t", "\r", "\n"," " ])* "{" >| < AGGREGATE_MIN_OB : "#min"([ "\t", "\r", "\n"," " ])* "{" >| < AGGREGATE_MAX_OB : "#max"([ "\t", "\r", "\n"," " ])* "{" >| < OSB : "[" >| < OCB : "]" >| < POUND_SIGN : "#" >}< IN_PROGRAM_RULES >TOKEN :{  < IDENTIFIER_WITH_OP : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n"," " ])* "(" >| < NEGATIVE_ATOM_WITH_OP : "-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n"," " ])* "(" >| < NEGATIVE_SORT_ATOM_WITH_OP : "-#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n"," " ])* "(" >| < NEGATIVE_ATOM : "-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >}< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >SKIP :{  < SINGLE_LINE_COMMENT :    "%" (~[ "\n", "\r" ])*    (      "\r"    | "\n"    | "\r\n"    )? >| < SPACE : ([ "\n", "\r", "\t", " " ])+ >}< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >TOKEN :{  < MINUS : "-" >}SimpleNode program() :{/*@bgen(jjtree) program */
  ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  sortNameToExpression = new HashMap < String, ASTsortExpression > ();  predicateArgumentSorts = new HashMap < String, ArrayList < String >> ();  crRuleLabels = new HashSet < String > ();  generatingSorts = new HashSet < String > ();  constantsMapping = new HashMap < String, Long > ();  warnings = new ArrayList < String > ();  curlyBracketTerms = new HashSet < String > ();  definedRecordNames = new HashSet < String > ();}{/*@bgen(jjtree) program */
  try {
/*@egen*/  directives(jjtn000.directives) sortDefinitions() predicateDeclarations() programRules() < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  } | < EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {
    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
  }void sortDefinitions() :{/*@bgen(jjtree) sortDefinitions */
  ASTsortDefinitions jjtn000 = new ASTsortDefinitions(JJTSORTDEFINITIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) sortDefinitions */
  try {
/*@egen*/  (    < SORTDEFKEYWORD >    (      sortDefinition()    )*  )|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void sortDefinition() :{/*@bgen(jjtree) sortDefinition */
  ASTsortDefinition jjtn000 = new ASTsortDefinition(JJTSORTDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  SimpleNode n;}{/*@bgen(jjtree) sortDefinition */
  try {
/*@egen*/  < POUND_SIGN > t = < IDENTIFIER > < EQ > n = sortExpression() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (sortNameToExpression.containsKey(t.image))    {      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was already defined");    }    for (String builtInSortName : BuiltIn.sortNames)    {      if (t.image.equals(builtInSortName))      {        throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " is built-in and cannot be redefined");      }    }    if (EmptySortChecker.isEmpty((ASTsortExpression) n, sortNameToExpression))    {      throw new ParseException("sort " + t.image + " defined at line " + t.beginLine + " column " + t.beginColumn + " is empty");    }    sortNameToExpression.put(t.image, (ASTsortExpression) n);  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode sortExpression() :{/*@bgen(jjtree) sortExpression */
  ASTsortExpression jjtn000 = new ASTsortExpression(JJTSORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  String s;}{/*@bgen(jjtree) sortExpression */
  try {
/*@egen*/
  LOOKAHEAD(2)  n = setExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| LOOKAHEAD({ (getToken(1) != null && (getToken(1).image) != null) && (constantsMapping.containsKey(getToken(1).image) || isInteger(getToken(1).image)) })  n = numericRange()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| LOOKAHEAD(identifierRange())  n = identifierRange()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| n = concatenation()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode setExpression() :{/*@bgen(jjtree) setExpression */
  ASTsetExpression jjtn000 = new ASTsetExpression(JJTSETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) setExpression */
  try {
/*@egen*/  n = additiveSetExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode multiplicativeSetExpression() :{/*@bgen(jjtree) multiplicativeSetExpression */
  ASTmultiplicativeSetExpression jjtn000 = new ASTmultiplicativeSetExpression(JJTMULTIPLICATIVESETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) multiplicativeSetExpression */
  try {
/*@egen*/  n = unarySetExpression()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    < MULT > unarySetExpression()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode additiveSetExpression() :{/*@bgen(jjtree) additiveSetExpression */
  ASTadditiveSetExpression jjtn000 = new ASTadditiveSetExpression(JJTADDITIVESETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  jjtn000.image = "+";  SimpleNode n;}{/*@bgen(jjtree) additiveSetExpression */
  try {
/*@egen*/  n = multiplicativeSetExpression()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    (      "+"      {        jjtn000.image += "+";      }    | "-"      {        jjtn000.image += "-";      }    )    multiplicativeSetExpression()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode sortName() :{/*@bgen(jjtree) sortName */
  ASTsortName jjtn000 = new ASTsortName(JJTSORTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) sortName */
  try {
/*@egen*/  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (!sortNameToExpression.containsKey(t.image))    {      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");    }    else    {      jjtn000.image = t.image;      jjtn000.beginLine = t.beginLine;      jjtn000.beginColumn = t.beginColumn;    }    return jjtn000;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode unarySetExpression() :{/*@bgen(jjtree) unarySetExpression */
  ASTunarySetExpression jjtn000 = new ASTunarySetExpression(JJTUNARYSETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  SimpleNode n;}{/*@bgen(jjtree) unarySetExpression */
  try {
/*@egen*/  t = < POUND_SIGN > sortName()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }| n = curlyBrackets()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| t = < OP > setExpression() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }

  | n = functionalSymbol()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  {
    if (!FunctionalSymbolChecker.checkFunctionalSymbolSorts((ASTfunctionalSymbol) n, sortNameToExpression))
    {
      throw new ParseException("the definition of record " + n.image + " at line " + n.beginLine + " column " + n.beginColumn + " has a condition which involves " + "checking less/greater relations on elements of non-basic sorts");
    }
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode curlyBrackets() :{/*@bgen(jjtree) curlyBrackets */
  ASTcurlyBrackets jjtn000 = new ASTcurlyBrackets(JJTCURLYBRACKETS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  SimpleNode child;}{/*@bgen(jjtree) curlyBrackets */
  try {
/*@egen*/  t = < OB > child = constantTermList() < CB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    CurlyBrackets.retrieveAllTerms((ASTconstantTermList) child, curlyBracketTerms);    CurlyBrackets.retrieveAllFunctionalSymbols(jjtn000, definedRecordNames);    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void concatenationTermList()                   :{/*@bgen(jjtree) constantTermList */
  ASTconstantTermList jjtn000 = new ASTconstantTermList(JJTCONSTANTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) constantTermList */
  try {
/*@egen*/  concatenationTerm()  (    < COMMA > concatenationTerm()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode constantTermList() :{/*@bgen(jjtree) constantTermList */
  ASTconstantTermList jjtn000 = new ASTconstantTermList(JJTCONSTANTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) constantTermList */
  try {
/*@egen*/  constantTerm()  (    < COMMA > constantTerm()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void constantTerm():{/*@bgen(jjtree) constantTerm */
  ASTconstantTerm jjtn000 = new ASTconstantTerm(JJTCONSTANTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1, t2, t3;  String s;}{/*@bgen(jjtree) constantTerm */
  try {
/*@egen*/  LOOKAHEAD({ (getToken(1) != null && (getToken(1).image) != null) && (constantsMapping.containsKey(getToken(1).image) || isInteger(getToken(1).image)) })  t1 = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(2)  t1 = < IDENTIFIER > t3 = < OP > constantTermList() t2 = < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image + t3.image + " " + t2.image;  }| t1 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void concatenationTerm()               :{/*@bgen(jjtree) constantTerm */
  ASTconstantTerm jjtn000 = new ASTconstantTerm(JJTCONSTANTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1;}{/*@bgen(jjtree) constantTerm */
  try {
/*@egen*/  LOOKAHEAD({ constantsMapping.containsKey(getToken(1).image) })  t1 = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| t1 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode condition(HashMap < String, Integer > varMap) :{/*@bgen(jjtree) condition */
  ASTcondition jjtn000 = new ASTcondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t, t1, t2;}{/*@bgen(jjtree) condition */
  try {
/*@egen*/  orCondition(varMap)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void orCondition(HashMap < String, Integer > varMap) :{/*@bgen(jjtree) orCondition */
  ASTorCondition jjtn000 = new ASTorCondition(JJTORCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) orCondition */
  try {
/*@egen*/  andCondition(varMap)  (    < OR > andCondition(varMap)  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void andCondition(HashMap < String, Integer > varMap) :{/*@bgen(jjtree) andCondition */
  ASTandCondition jjtn000 = new ASTandCondition(JJTANDCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) andCondition */
  try {
/*@egen*/  unaryCondition(varMap)  (    < AND > unaryCondition(varMap)  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void unaryCondition(HashMap < String, Integer > varMap) :{/*@bgen(jjtree) unaryCondition */
  ASTunaryCondition jjtn000 = new ASTunaryCondition(JJTUNARYCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t, t3, t4;}{/*@bgen(jjtree) unaryCondition */
  try {
/*@egen*/  t3 = var()  {    jjtn000.image = varMap.get(t3.image).toString();  }  t = rel()  {    jjtn000.image += " " + t.image;  }  t4 = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image += " " + varMap.get(t4.image).toString();  }| < OP > condition(varMap) < CP >| t = < NOTOP > condition(varMap) < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode functionalSymbol() :{/*@bgen(jjtree) functionalSymbol */
  ASTfunctionalSymbol jjtn000 = new ASTfunctionalSymbol(JJTFUNCTIONALSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1, t2, t3;  Token from, to;  HashMap < String, Integer > map;  HashSet < Integer > BasicSorts;  SimpleNode c = null;}{/*@bgen(jjtree) functionalSymbol */
  try {
/*@egen*/  t1 = < IDENTIFIER > t3 = < OP >  {}  map = specialSortExpressionList() t2 = < CP > [ < COLON > c = condition(map) ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    definedRecordNames.add(t1.image);    jjtn000.beginLine = t1.beginLine;    jjtn000.beginColumn = t1.beginColumn;    jjtn000.image = t1.image + t3.image + t2.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token specialSortExpression()       :{  Token sortToken,t = null;}{  < POUND_SIGN > sortName() [ < OP > t = < VARIABLE > < CP > ]  {    return t;  }}HashMap < String, Integer > specialSortExpressionList()                     :{/*@bgen(jjtree) sortExpressionList */
  ASTsortExpressionList jjtn000 = new ASTsortExpressionList(JJTSORTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  HashMap < String, Integer > variableMapping = new HashMap < String, Integer > ();  int agr = 0;  Token t;}{/*@bgen(jjtree) sortExpressionList */
  try {
/*@egen*/  t = specialSortExpression()  {    if (t != null)    {      if (variableMapping.containsKey(t.image))      {        throw new ParseException("variable " + t.image + " at line " + t.beginLine + ", column " + t.beginColumn + " is used more than once in " + "record definition");      }      variableMapping.put(t.image, agr);    }    agr++;  }  (    < COMMA > t = specialSortExpression()    {      if (t != null)      {        if (variableMapping.containsKey(t.image))        {          throw new ParseException("variable " + t.image + " at line " + t.beginLine + ", column " + t.beginColumn + " is used more than once in " + "record definition");        }        variableMapping.put(t.image, agr);      }      agr++;    }  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return variableMapping;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode concatenation() :{/*@bgen(jjtree) concatenation */
  ASTconcatenation jjtn000 = new ASTconcatenation(JJTCONCATENATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) concatenation */
  try {
/*@egen*/  (    < OSB > basicSort() < OCB >  )+/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void basicSort() :{/*@bgen(jjtree) basicSort */
  ASTbasicSort jjtn000 = new ASTbasicSort(JJTBASICSORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode se;  Token t;  String s;}{/*@bgen(jjtree) basicSort */
  try {
/*@egen*/  LOOKAHEAD({ (getToken(1) != null && (s = getToken(1).image) != null) && (constantsMapping.containsKey(s) || isInteger(s)) })  numericRange()| LOOKAHEAD(identifierRange())  identifierRange()| t = < POUND_SIGN > se = sortName()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (!sortNameToExpression.containsKey(se.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + t.image + "' was not defined");    }    ASTsortExpression ex = sortNameToExpression.get(se.image);    if (!BasicSortChecker.isBasic(ex, sortNameToExpression))    {      throw new ParseException("ERROR: Sort '" + se.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " is not a basic sort");    }  }| concatenationTermList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode identifierRange() :{/*@bgen(jjtree) identifierRange */
  ASTidentifierRange jjtn000 = new ASTidentifierRange(JJTIDENTIFIERRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1, t2;}{/*@bgen(jjtree) identifierRange */
  try {
/*@egen*/  t1 = < IDENTIFIER > < DOT > < DOT > t2 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    int errorLine = t1.beginLine;    int errorColumn = t1.beginColumn;    if (t1.image.length() > t2.image.length())    {      throw new ParseException("ERROR: the length of the first identifier in identifier range should be smaller or equal to the length of the second one " + "at line " + errorLine + ", column " + errorColumn);    }    if (t1.image.compareTo(t2.image) > 0)    {      throw new ParseException("ERROR: the first identifier in identifier range should be lexicographically smaller or equal to  the second one " + "at line " + errorLine + ", column " + errorColumn);    }    jjtn000.image = t1.image + " " + t2.image;
    return jjtn000;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode numericRange() :{/*@bgen(jjtree) numericRange */
  ASTnumericRange jjtn000 = new ASTnumericRange(JJTNUMERICRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token from, to;}{/*@bgen(jjtree) numericRange */
  try {
/*@egen*/  from = number()  {    jjtn000.beginLine = from.beginLine;    jjtn000.beginColumn = from.beginColumn;  }  < DOT > < DOT > to = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    int fromI = 0;    int toI = 0;    try    {      fromI = Integer.parseInt(from.image);      toI = Integer.parseInt(to.image);    }    catch (NumberFormatException ex)    {}    if (fromI > toI)    {      throw new ParseException("ERROR: the first number in numeric  range should be smaller or equal to  the second one " + "at line " + to.beginLine + ", column " + to.beginColumn);    }    jjtn000.image = from.image + " " + to.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token number()       :{  Token t;}{  t = < POSITIVE_INTEGER >  {
    int integer = Integer.parseInt(t.image);
	if(integer >  BuiltIn.getMaxInt() )	{	    throw new ParseException("ERROR: Integer '" + t.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " is out of range");
    }    return t;  }| t = < ZERO >  {    return t;  }| t = < NONZERODIGIT >  {    return t;  }| t = < IDENTIFIER >  {    if (!constantsMapping.containsKey(t.image))    {      throw new ParseException("ERROR: Constant '" + t.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " was not defined");      //return t;
    }    else    {      t.image = constantsMapping.get(t.image).toString();      return t;    }  }}void predicateDeclarations() :{/*@bgen(jjtree) predicateDeclarations */
  ASTpredicateDeclarations jjtn000 = new ASTpredicateDeclarations(JJTPREDICATEDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) predicateDeclarations */
  try {
/*@egen*/  < PREDDEFKEYWORD >  (    predicateDeclaration()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    HashSet < String > usedPredicateNames = new HashSet < String > ();    usedPredicateNames.addAll(predicateArgumentSorts.keySet());
    HashMap<String,String > sortRenaming=new HashMap<String,String >();    for (String sortName : sortNameToExpression.keySet())    {      predicateArgumentSorts.put("#" + sortName, new ArrayList < String > ());      String nameCandidate = sortName;      while (usedPredicateNames.contains(nameCandidate))      {        nameCandidate += "_";      }      usedPredicateNames.add(nameCandidate);      predicateArgumentSorts.get("#" + sortName).add(nameCandidate);
      if(!sortName.equals(nameCandidate))      {
        //update all sort names from predicate lists:
        sortRenaming.put(sortName,nameCandidate);
        for(String predicateName:predicateArgumentSorts.keySet())        {           ArrayList<String > arguments= predicateArgumentSorts.get(predicateName);
           for(int i=0;i<arguments.size();i++)           {               if(arguments.get(i).equals(sortName))               {
                 arguments.set(i,nameCandidate);               }
           }
        }

        // update all sort names in functional symbol definitions!!!

        for(String sortName1:sortNameToExpression.keySet())        {
          ASTsortExpression se= sortNameToExpression.get(sortName1);
          SimpleNode child = (SimpleNode)se.jjtGetChild(0);
          if(child.getId() == SparcTranslatorTreeConstants.JJTSETEXPRESSION)          {
            SimpleNode additiveSetExpr = (SimpleNode) child.jjtGetChild(0);
            for(int i=0;i<additiveSetExpr.jjtGetNumChildren();i++)            {
              SimpleNode multiplicativeSetExpr = (SimpleNode) additiveSetExpr.jjtGetChild(i);
              for(int j=0;j<multiplicativeSetExpr.jjtGetNumChildren();j++)              {                   SimpleNode unarySortExpr = (SimpleNode) multiplicativeSetExpr.jjtGetChild(j);
                   child = (SimpleNode)unarySortExpr.jjtGetChild(0);
                   if(child.getId() == SparcTranslatorTreeConstants.JJTFUNCTIONALSYMBOL)
                   {
                       ASTsortExpressionList sortNameList = (ASTsortExpressionList)child.jjtGetChild(0);
                       for(int k=0;k<sortNameList.jjtGetNumChildren();k++)
                       {           
                            ASTsortName oldSortName = (ASTsortName)sortNameList.jjtGetChild(k);
                            if(oldSortName.image.equals(sortName))                            {
                                oldSortName.image = sortRenaming.get(oldSortName.image);                            }                          
                       }
                  }
              }            }              }        }      }    }
    for(String sortName:sortRenaming.keySet())    {
        sortNameToExpression.put(sortRenaming.get(sortName),sortNameToExpression.get(sortName));
        sortNameToExpression.remove(sortName);    }  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void predicateDeclaration() :{/*@bgen(jjtree) predicateDeclaration */
  ASTpredicateDeclaration jjtn000 = new ASTpredicateDeclaration(JJTPREDICATEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  ArrayList < String > arguments = new ArrayList < String > ();}{/*@bgen(jjtree) predicateDeclaration */
  try {
/*@egen*/  t = < IDENTIFIER >  {    if (predicateArgumentSorts.containsKey(t.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "predicate " + t.image + " was already declared");    }    if (BuiltInPredicates.predicateNamesSet.contains(t.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "predicate " + t.image + " is a built-in predicate");    }  }  < OP >  (    arguments = identifierList()  )?  {    predicateArgumentSorts.put(t.image, arguments);  }  < CP > < DOT >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}ArrayList < String > identifierList() :{/*@bgen(jjtree) identifierList */
  ASTidentifierList jjtn000 = new ASTidentifierList(JJTIDENTIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  ArrayList < String > result = new ArrayList < String > ();  Token t;}{/*@bgen(jjtree) identifierList */
  try {
/*@egen*/
    (    < POUND_SIGN > t = < IDENTIFIER >  {    if (!sortNameToExpression.containsKey(t.image))    {      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + t.image + "' was not defined");    }    result.add(t.image);  }  (    < COMMA > < POUND_SIGN > t = < IDENTIFIER >    {
     if (!sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + t.image + "' was not defined");
    }      result.add(t.image);    }  )*)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return result;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode programRules() :{/*@bgen(jjtree) programRules */
  ASTprogramRules jjtn000 = new ASTprogramRules(JJTPROGRAMRULES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) programRules */
  try {
/*@egen*/  < PROGRULDEFKEYWORD >  (    programRule()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode programRule() :{/*@bgen(jjtree) programRule */
  ASTprogramRule jjtn000 = new ASTprogramRule(JJTPROGRAMRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  SimpleNode n;  inHead = true;}{/*@bgen(jjtree) programRule */
  try {
/*@egen*/  LOOKAHEAD(2)  t = label()  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    jjtn000.setLabel(t.image);    if (crRuleLabels.contains(t.image))    {      throw new ParseException("cr-rule label " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " occures more then once");    }    else    {      crRuleLabels.add(t.image);    }  }  n = unlabeledProgramCrRule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| n = unlabeledProgramRule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode unlabeledProgramRule() :{/*@bgen(jjtree) unlabeledProgramRule */
  ASTunlabeledProgramRule jjtn000 = new ASTunlabeledProgramRule(JJTUNLABELEDPROGRAMRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Pair n;  SimpleNode n2;  Token from, to, sep;}{/*@bgen(jjtree) unlabeledProgramRule */
  try {
/*@egen*/  LOOKAHEAD(predSymbol() number() < DOT >)  n = predSymbol() from = number() < DOT > < DOT > to = number() < CP > < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ //can be body here after safety fix!
  {    jjtn000.beginLine = n.first.beginLine;    jjtn000.beginColumn = n.first.beginColumn;    jjtn000.image = n.first.image + " " + from.image + " " + to.image;    inHead = false;    return jjtn000;  }| n2 = head()  {    inHead = false;  }  sep = exBody()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = sep.image;    jjtn000.beginLine = n2.beginLine;    jjtn000.beginColumn = n2.beginColumn;    return jjtn000;  }| sep = < ORRSEP >  {    inHead = false;    jjtn000.image = sep.image;    jjtn000.beginLine = sep.beginLine;    jjtn000.beginColumn = sep.beginColumn;  }  body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }| sep = < CRRSEP >  {    inHead = false;    jjtn000.beginLine = sep.beginLine;    jjtn000.beginColumn = sep.beginColumn;    jjtn000.image = sep.image;  }  body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }| sep = < WEAKSEP >  {    inHead = false;    jjtn000.beginLine = sep.beginLine;    jjtn000.beginColumn = sep.beginColumn;    jjtn000.image = sep.image;  }  body() < DOT > [ constraintParams() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void constraintParams() :{/*@bgen(jjtree) constraintParams */
  ASTconstraintParams jjtn000 = new ASTconstraintParams(JJTCONSTRAINTPARAMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t0;  Token t1 = null, t2 = null, t3 = null, t4 = null, t5 = null;  jjtn000.image = "";}{/*@bgen(jjtree) constraintParams */
  try {
/*@egen*/  t0 = < OSB >  [    (      t1 = var()    | t2 = number()    )  ]  t5 = < COLON >  [    (      t3 = var()    | t4 = number()    )  ]  < OCB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (t1 == null && t2 == null && t3 == null && t4 == null)    {      throw new ParseException("line " + t0.beginLine + ", column " + t0.beginColumn + ": weak constraint paramethers cannot both be empty");    }    if (t2 != null)    {      jjtn000.image += t2.image;    }    else if (t1 != null)    {      jjtn000.image += "V";    }    jjtn000.image += t5.image;    if (t4 != null)    {      jjtn000.image += t4.image;    }    else if (t3 != null)    {      jjtn000.image += "V";    }  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode unlabeledProgramCrRule() :{/*@bgen(jjtree) unlabeledProgramCrRule */
  ASTunlabeledProgramCrRule jjtn000 = new ASTunlabeledProgramCrRule(JJTUNLABELEDPROGRAMCRRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  Token t;}{/*@bgen(jjtree) unlabeledProgramCrRule */
  try {
/*@egen*/  n = head() t = exCrBody()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    jjtn000.image = t.image;    return jjtn000;  }| t = < CRRSEP > body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    jjtn000.image = t.image;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token label()       :{  Token t;}{  t = < IDENTIFIER > < COLON >  {    return t;  }}Token exBody()       :{  Token t;}{  t = exStandartBody()  {    return t;  }| t = exCrBody()  {    return t;  }}Token exStandartBody()       :{  Token t;}{  t = < ORRSEP > body() < DOT >  {    return t;  }| t = < DOT >  {    return new Token(SparcTranslatorConstants.ORRSEP, ":-");  }}Token exCrBody()       :{  Token t;}{  t = < CRRSEP > crBodyWithoutSep()  {    return t;  }}void crBodyWithoutSep()       :{}{  < DOT >| body() < DOT >}SimpleNode head() :{/*@bgen(jjtree) head */
  ASThead jjtn000 = new ASThead(JJTHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) head */
  try {
/*@egen*/  LOOKAHEAD(2)  n = choice_rule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| n = disjunction()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode disjunction() :{/*@bgen(jjtree) disjunction */
  ASTdisjunction jjtn000 = new ASTdisjunction(JJTDISJUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) disjunction */
  try {
/*@egen*/  n = nonRelAtom()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    < HEAD_OR > nonRelAtom()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode choice_rule() :{/*@bgen(jjtree) choice_rule */
  ASTchoice_rule jjtn000 = new ASTchoice_rule(JJTCHOICE_RULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n1 = null;  Token t;}{/*@bgen(jjtree) choice_rule */
  try {
/*@egen*/  [    n1 = arithmeticTerm()    [      t = rel()      {        jjtn000.image = "L" + t.image;      }    ]  ]  t = < OB > choice_elements() < CB >  [    [      t = rel()      {        jjtn000.image += " R" + t.image;      }    ]    arithmeticTerm()  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (n1 != null)    {      jjtn000.beginLine = n1.beginLine;      jjtn000.beginColumn = n1.beginColumn;    }    else    {      jjtn000.beginLine = t.beginLine;      jjtn000.beginColumn = t.beginColumn;    }    if (Settings.getSingletonInstance().getSolver() != ASPSolver.Clingo)     throw new ParseException("line " + jjtn000.beginLine + ", column " + jjtn000.beginColumn + ": choice rules are not supported in DLV");    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void choice_elements() :{/*@bgen(jjtree) choice_elements */
  ASTchoice_elements jjtn000 = new ASTchoice_elements(JJTCHOICE_ELEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) choice_elements */
  try {
/*@egen*/  choice_element()  (    < SEMICOLON > choice_element()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void choice_element() :{/*@bgen(jjtree) choice_element */
  ASTchoice_element jjtn000 = new ASTchoice_element(JJTCHOICE_ELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) choice_element */
  try {
/*@egen*/  n = nonRelAtom() [ < COLON > extendedSimpleAtomList() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void extendedSimpleAtomList() :{/*@bgen(jjtree) extendedSimpleAtomList */
  ASTextendedSimpleAtomList jjtn000 = new ASTextendedSimpleAtomList(JJTEXTENDEDSIMPLEATOMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) extendedSimpleAtomList */
  try {
/*@egen*/  simpleAtom()  (    < COMMA > simpleAtom()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void body() :{/*@bgen(jjtree) body */
  ASTbody jjtn000 = new ASTbody(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) body */
  try {
/*@egen*/  atom()  (    < COMMA > atom()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token var() :{/*@bgen(jjtree) var */
  ASTvar jjtn000 = new ASTvar(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) var */
  try {
/*@egen*/  t = < VARIABLE >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.setOriginalImage(t.image);    return t;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode nonRelAtom() :{/*@bgen(jjtree) nonRelAtom */
  ASTnonRelAtom jjtn000 = new ASTnonRelAtom(JJTNONRELATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode tList = null;  Pair n;}{/*@bgen(jjtree) nonRelAtom */
  try {
/*@egen*/  n = predSymbol()  {    jjtn000.beginLine = n.first.beginLine;    jjtn000.beginColumn = n.first.beginColumn;  }  [    tList = termList()    {      if (!n.second && tList != null)      {        throw new ParseException("ERROR:( expected at line " + tList.beginLine + " column " + tList.beginColumn);      }    }    < CP >  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    ASTpredSymbol predS = (ASTpredSymbol) n.first;    if (predS.hasPoundSign && (tList == null || tList.jjtGetNumChildren() != 1))    {      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " must have exactly one argument");    }    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void simpleAtom() :{/*@bgen(jjtree) simpleAtom */
  ASTsimpleAtom jjtn000 = new ASTsimpleAtom(JJTSIMPLEATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  Token t;}{/*@bgen(jjtree) simpleAtom */
  try {
/*@egen*/  LOOKAHEAD(symbolicTerm() rel() symbolicTerm())  symbolicTerm() t = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| LOOKAHEAD(symbolicTerm() rel() var())  symbolicTerm() t = rel() var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())  arithmeticTerm() t = rel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| LOOKAHEAD(var() rel() symbolicTerm())  var() t = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())  arithmeticTerm() t = eqrel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())  symbolicTerm() t = eqrel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| n = extendedNonRelAtom()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = n.image;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode extendedNonRelAtom() :{/*@bgen(jjtree) extendedNonRelAtom */
  ASTextendedNonRelAtom jjtn000 = new ASTextendedNonRelAtom(JJTEXTENDEDNONRELATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;  jjtn000.image = "";  SimpleNode tList = null;  Pair n;}{/*@bgen(jjtree) extendedNonRelAtom */
  try {
/*@egen*/  [    t = < NOT >    {      jjtn000.image = t.image;    }  ]  n = predSymbol()  [    tList = termList()    {      if (!n.second && tList != null)      {        throw new ParseException("ERROR:( expected at line " + tList.beginLine + " column " + tList.beginColumn);      }    }    < CP >  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    ASTpredSymbol predS = (ASTpredSymbol) n.first;    if (predS.hasPoundSign && (tList == null || tList.jjtGetNumChildren() != 1))    {      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " must have exactly one argument");    }    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode addOp()       :{  Token t;  SimpleNode n = new SimpleNode(0);}{  t = < PLUS >  {    n.image = t.image;    return n;  }| t = < MINUS >  {    n.image = t.image;    return n;  }}SimpleNode multOp()       :{  Token t;  SimpleNode n = new SimpleNode(0);}{  t = < MULT >  {    n.image = t.image;    return n;  }| t = < DIV >  {    n.image = t.image;    return n;  }}SimpleNode arithmeticTerm() :{/*@bgen(jjtree) arithmeticTerm */
  ASTarithmeticTerm jjtn000 = new ASTarithmeticTerm(JJTARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) arithmeticTerm */
  try {
/*@egen*/  n = additiveArithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode atomicArithmeticTerm() :{/*@bgen(jjtree) atomicArithmeticTerm */
  ASTatomicArithmeticTerm jjtn000 = new ASTatomicArithmeticTerm(JJTATOMICARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;
 }{/*@bgen(jjtree) atomicArithmeticTerm */
  try {
/*@egen*/
  
  LOOKAHEAD({  (getToken(1) != null && getToken(1).image != null) && (constantsMapping.containsKey(getToken(1).image ) || isInteger(getToken(1).image )) })  t = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }| t = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }| t = < OP > arithmeticTerm() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode additiveArithmeticTerm() :{/*@bgen(jjtree) additiveArithmeticTerm */
  ASTadditiveArithmeticTerm jjtn000 = new ASTadditiveArithmeticTerm(JJTADDITIVEARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  jjtn000.image = "+";}{/*@bgen(jjtree) additiveArithmeticTerm */
  try {
/*@egen*/  n = multiplicativeArithmeticTerm()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    n = addOp()    {      jjtn000.image += n.image;    }    multiplicativeArithmeticTerm()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode multiplicativeArithmeticTerm() :{/*@bgen(jjtree) multiplicativeArithmeticTerm */
  ASTmultiplicativeArithmeticTerm jjtn000 = new ASTmultiplicativeArithmeticTerm(JJTMULTIPLICATIVEARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  jjtn000.image = "";}{/*@bgen(jjtree) multiplicativeArithmeticTerm */
  try {
/*@egen*/  n = atomicArithmeticTerm()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  (    n = multOp()    {      jjtn000.image += n.image;    }    atomicArithmeticTerm()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode symbolicFunction() :{/*@bgen(jjtree) symbolicFunction */
  ASTsymbolicFunction jjtn000 = new ASTsymbolicFunction(JJTSYMBOLICFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) symbolicFunction */
  try {
/*@egen*/  t = < IDENTIFIER_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginColumn = t.beginColumn;    jjtn000.beginLine = t.beginLine;    return jjtn000;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}
SimpleNode symbolicConstant() :
{/*@bgen(jjtree) symbolicConstant */
  ASTsymbolicConstant jjtn000 = new ASTsymbolicConstant(JJTSYMBOLICCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) symbolicConstant */
  try {
/*@egen*/
  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}SimpleNode symbolicTerm() :{/*@bgen(jjtree) symbolicTerm */
  ASTsymbolicTerm jjtn000 = new ASTsymbolicTerm(JJTSYMBOLICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) symbolicTerm */
  try {
/*@egen*/  n = symbolicConstant()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }| n = symbolicFunction()  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }  termList() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}SimpleNode term() :{/*@bgen(jjtree) term */
  ASTterm jjtn000 = new ASTterm(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;  Token t;  jjtn000.image = "";}{/*@bgen(jjtree) term */
 try {
/*@egen*/ LOOKAHEAD(var() (< CP >| < COMMA >))  t = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    //System.out.println("t.image");
    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return jjtn000;  }
| 
  LOOKAHEAD(2)
  n = arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }| n = symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;    return jjtn000;  }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/}SimpleNode termList() :{/*@bgen(jjtree) termList */
  ASTtermList jjtn000 = new ASTtermList(JJTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode t;}{/*@bgen(jjtree) termList */
  try {
/*@egen*/  t = term()  {    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;  }  (    < COMMA > term()  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    return jjtn000;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}Token rel()       :{  Token t;}{  t = < EQ >  {    return t;  }| t = < NOTEQ >  {    return t;  }| t = < GT >  {    return t;  }| t = < GTEQ >  {    return t;  }| t = < SM >  {    return t;  }| t = < SMEQ >  {    return t;  }| t = < EQR >  {    return t;  }}Token eqrel()       :{  Token t;}{  t = < EQ >  {    return t;  }| t = < NOTEQ >  {    return t;  }}Pair predSymbol() :{/*@bgen(jjtree) predSymbol */
  ASTpredSymbol jjtn000 = new ASTpredSymbol(JJTPREDSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t, poundSign = null;}{/*@bgen(jjtree) predSymbol */
  try {
/*@egen*/  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return new Pair(jjtn000, false);  }| [ poundSign = < POUND_SIGN > ] t = < IDENTIFIER_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (poundSign != null)    {      jjtn000.setPoundSign(true);      if (inHead)      {        throw new ParseException("sort name " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");      }      String sort = "#" + t.image.substring(0, t.image.length() - 1);      if (!predicateArgumentSorts.containsKey(sort))      {        throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");      }      else      {        jjtn000.setTranslatedImage(predicateArgumentSorts.get(sort).get(0));        t.image = poundSign.image + t.image;      }    }    jjtn000.image = t.image.substring(0, t.image.length() - 1);    if (sortNameToExpression.containsKey(jjtn000.image))    {      generatingSorts.add(jjtn000.image);    }    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return new Pair(jjtn000, true);  }| t = < NEGATIVE_ATOM_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.negative = true;    jjtn000.image = t.image.substring(1, t.image.length() - 1);    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return new Pair(jjtn000, true);  }| t = < NEGATIVE_ATOM >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.negative = true;    jjtn000.image = t.image.substring(1, t.image.length());    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return new Pair(jjtn000, false);  }| t = < NEGATIVE_SORT_ATOM_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.setPoundSign(true);    if (inHead)    {      throw new ParseException("sort name " + t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");    }    String sort = t.image.substring(1, t.image.length() - 1);    if (!predicateArgumentSorts.containsKey(sort))    {      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");    }    else    {      jjtn000.setTranslatedImage(predicateArgumentSorts.get(sort).get(0));      t.image = "#" + t.image.substring(1, t.image.length());      ;    }    jjtn000.negative = true;    jjtn000.image = t.image.substring(0, t.image.length() - 1);    jjtn000.beginLine = t.beginLine;    jjtn000.beginColumn = t.beginColumn;    return new Pair(jjtn000, true);  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void atom() :{/*@bgen(jjtree) atom */
  ASTatom jjtn000 = new ASTatom(JJTATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1;}{/*@bgen(jjtree) atom */
  try {
/*@egen*/  LOOKAHEAD([ arithmeticTerm() rel() ] aggregateFunction())  aggregate()| LOOKAHEAD(symbolicTerm() rel() symbolicTerm())  symbolicTerm() t1 = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(symbolicTerm() rel() var())  symbolicTerm() t1 = rel() var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(var() rel() symbolicTerm())  var() t1 = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())  arithmeticTerm() t1 = eqrel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())  symbolicTerm() t1 = eqrel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())  arithmeticTerm() t1 = rel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t1.image;  }| extendedNonRelAtom()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregate() :{/*@bgen(jjtree) aggregate */
  ASTaggregate jjtn000 = new ASTaggregate(JJTAGGREGATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t1 = null, t2 = null;  jjtn000.image = "";}{/*@bgen(jjtree) aggregate */
  try {
/*@egen*/  [ arithmeticTerm() t1 = rel() ] aggregateFunction() aggregateElements() < CB > [ t2 = rel() arithmeticTerm() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    if (t1 != null)    {      jjtn000.image += "L" + t1.image;    }    if (t2 != null)    {      jjtn000.image += "R" + t2.image;    }  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregateElements() :{/*@bgen(jjtree) aggregateElements */
  ASTaggregateElements jjtn000 = new ASTaggregateElements(JJTAGGREGATEELEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) aggregateElements */
  try {
/*@egen*/  aggregateElement()  (    < SEMICOLON > aggregateElement()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregateElement() :{/*@bgen(jjtree) aggregateElement */
  ASTaggregateElement jjtn000 = new ASTaggregateElement(JJTAGGREGATEELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  SimpleNode n;}{/*@bgen(jjtree) aggregateElement */
  try {
/*@egen*/  (    LOOKAHEAD(2)    n = nonRelAtom()  | n = arithmeticTerm()  )  (    < COMMA >    (      LOOKAHEAD(2)      nonRelAtom()    | arithmeticTerm()    )  )*  [ < COLON > extendedSimpleAtomList() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.beginLine = n.beginLine;    jjtn000.beginColumn = n.beginColumn;  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void aggregateFunction() :{/*@bgen(jjtree) aggregateFunction */
  ASTaggregateFunction jjtn000 = new ASTaggregateFunction(JJTAGGREGATEFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/  Token t;}{/*@bgen(jjtree) aggregateFunction */
  try {
/*@egen*/  t = < AGGREGATE_COUNT_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| t = < AGGREGATE_MAX_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| t = < AGGREGATE_MIN_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }| t = < AGGREGATE_SUM_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/  {    jjtn000.image = t.image;  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void atomSequence() :{/*@bgen(jjtree) atomSequence */
  ASTatomSequence jjtn000 = new ASTatomSequence(JJTATOMSEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}{/*@bgen(jjtree) atomSequence */
  try {
/*@egen*/  atom()  (    < COMMA > atom()  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}void directives(ArrayList < String > directives)       :{}{  (    directive(directives)  )*  {    addBuiltInSorts();  }}void directive(ArrayList < String > directives)       :{  Token t, t1, t2, t3, t4;}{  t = < MAXINTDIRECTIVE > t1 = < EQ > t2 = < POSITIVE_INTEGER > t3 = < DOT >  {
    Integer value = Integer.parseInt(t2.image);    BuiltIn.setMaxInt(value);  }| t = < CONSTDIRECTIVE > t1 = < IDENTIFIER > t2 = < EQ > t3 = number() t4 = < DOT >  {    directives.add(t.image + " " + t1.image + t2.image + t3.image + t4.image);    constantsMapping.put(t1.image, Long.parseLong(t3.image));  }}
