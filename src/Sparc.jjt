//TODO: change extendedNonRelAtom to extendedAtom.
options
{
  BUILD_PARSER = true;
  STATIC = false;
  OUTPUT_DIRECTORY = "/home/iensen/Projects/sparc/src/project/src/parser";
  MULTI = true;
}

PARSER_BEGIN(SparcTranslator)
package parser;
import java.io.*;
import sorts.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Arrays;
import java.util.Set;
import translating.Translator;
import typechecking.TypeChecker;
import typechecking.RecordInfo;
import translating.InstanceGenerator;
import com.beust.jcommander.Parameter;
import com.beust.jcommander.JCommander;
import com.beust.jcommander.ParameterException;
import querying.QueryEngine;
import querying.parsing.AnswerSets.AnswerSetParser;
import querying.parsing.AnswerSets.ClingoAnswerSetParser;
import querying.parsing.AnswerSets.DLVAnswerSetParser;
import configuration.ASPSolver;
import externaltools.ClingoSolver;
import externaltools.DLVSolver;
import externaltools.ExternalSolver;
import configuration.Settings;
import solving.Runner;
import signatureprinting.SortedSignaturePrinter;

class Arguments
{
  @ Parameter(description = "Input files") List < String > inputFiles = new ArrayList < String > ();
  @ Parameter(names = "-wasp", description = "Generate ASP debugging rules") boolean generateASPWarnings = false;
  @ Parameter(names = "-wcon", description = "Generate warnings based on translation to clingcon") boolean generateClingconWarnings = false;
  @ Parameter(names =
  {
    "-Help", "-H", "-help", "--Help", "--help", "-h"
  }
  , help = true) boolean help;
  @ Parameter(names = "--disable-empty-sort-check", description = "Disable checking of sorts for being non-empty") boolean noEmptyCheck = false;
  @ Parameter(names = "--print-signature", description = "Print the signature in JSON format") boolean printSignature = false;
  @ Parameter(names = "-o", description = "Output file") String outputFile = null;
  @ Parameter(names = "-q", description = "Query") String query = null;
  @ Parameter(names = "-A", description = "outputAnswerSets") boolean outputAnswerSets = false;
  @ Parameter(names = "-web", description = "special things for online ide") boolean web = false;
  @ Parameter(names = "-loutput", description = "output answer sets in L format") boolean lout = false;
  @ Parameter(names = "-solver", description = "selected solver") String solver = null;
  @ Parameter(names = "-solveropts", description = "options passed to internal solver")
    String solverOpts = null;   
  @ Parameter(names = "-n", description = "options passed to internal solver") int numberOfAnswerSets = 0;
 }

class Pair
{
  SimpleNode first;
  boolean second;

  public Pair(SimpleNode first, boolean second)
  {
    this.first = first;
    this.second = second;
  }
}

@ SuppressWarnings("all") public class SparcTranslator
{
  // mapping from sort names to sort expressions assigned to the sorts
  public HashMap < String, ASTsortExpression > sortNameToExpression;

  // mapping from predicate names to a list of names of sorts describing
  // arguments
  public HashMap < String, ArrayList < String >> predicateArgumentSorts;

  // labels of cr-rules
  public HashSet < String > crRuleLabels;

  //sort occurred explicitly in the program
  public HashSet < String > generatingSorts;

  // mapping from constant names to their values.
  public HashMap < String, Long > constantsMapping;

  // warnings found during the translation
  private ArrayList < String > warnings;

  // set of all terms occurring in curly brackets and their subterms
  public HashSet < String > curlyBracketTerms;

  // set of all defined records
  public HashSet<RecordInfo> definedRecords;

  // hashmap from original sort names to sort names which match ASP syntax

  public HashMap<String, String > sortRenaming;


  // controlling the parsing
  boolean inHead = false;
  boolean inDisplay = true;

  int anonSortId = 0;
  /**
  * Remove from args all 
  */
  private static HashSet < String > fetchOptions(String [] args)
  {
    HashSet < String > options = new HashSet < String > ();
    for (int i = 0; i < args.length; i++)
    {
      if (args [i].startsWith("--"))
      {
        options.add(args [i]);
        args = ArrayUtils.removeNthElement(args, i);
        i--;
      }
    }
    return options;
  }

  private static final Set < String > supportedSolvers = new HashSet < String > (Arrays.asList("clingo", "dlv"));

  public static void main(String [] args)
  {
  
    Arguments jArguments = new Arguments();
    try
    {
      new JCommander(jArguments, args);
    }
    catch (ParameterException ex)
    {
      System.err.println("ERROR: " + ex.getMessage());
      return;
    }

    if(!jArguments.lout)
        System.err.println("SPARC  V2.57");
   
    if (jArguments.help)
    {
      show_usage();
      return;
    }
    
    if(!jArguments.outputAnswerSets && jArguments.numberOfAnswerSets != 0)
    {
           System.err.println("ERROR: Option -n=" + jArguments.numberOfAnswerSets + " cannot be used without option -A");
           return;
    }
    
    if (jArguments.solver != null)
    {
      if (!supportedSolvers.contains(jArguments.solver))
      {
        System.err.println("Unknown solver: " + jArguments.solver);
        return;
      }
    }
    if (jArguments.solver != null)
    {
      if (jArguments.solver.equals("clingo")) 
         Settings.getSingletonInstance().setSolver(ASPSolver.Clingo);
      else if (jArguments.solver.equals("dlv"))
         Settings.getSingletonInstance().setSolver(ASPSolver.DLV);
    }

    Settings.setLOutputFormat(jArguments.lout);
    Settings.setWebMode(jArguments.web);
    Settings.setEmptySortCheckingDisabled(jArguments.noEmptyCheck);
    Settings.setRequiredNumberOfComputedAnswerSets(jArguments.numberOfAnswerSets);
    
    if (jArguments.solverOpts != null)
    {
      System.err.println("The option -solveropts is deprecated. Use option -n to specify the number" + 
      "of answer sets that need to be displayed and display statements to specify which predicates need to be displayed.");
      return;
    }

    if(jArguments.query != null)
    {
      Settings.setCommandLineQuery(jArguments.query);
    }
 
    Reader sr = null;
    Writer out = null;
    if (jArguments.outputFile != null)
    {
      if (new File(jArguments.outputFile).exists() && !new File(jArguments.outputFile).isDirectory())
      {
        System.err.println("the output file already exists , do you want to overwrite it? y/n:");
        char rep;
        try
        {
          InputStreamReader converter = new InputStreamReader(System.in);
		  BufferedReader in = new BufferedReader(converter);
          rep =in.readLine().charAt(0); 
        }
        catch (IOException e)
        {
          e.printStackTrace();
          return;
        }
        if (rep != 'y' && rep != 'Y')
        {
          return;
        }
      }
      try
      {
        out = new FileWriter(jArguments.outputFile);
      }
      catch (IOException e)
      {
        e.printStackTrace();
      }
    }
    
    TypeChecker tc = null;
    StringBuilder translatedProgram = new StringBuilder();
    SimpleNode programTree = null;
    try
    {
      if (jArguments.inputFiles != null && jArguments.inputFiles.size() != 0)
      {
        if (jArguments.inputFiles.size() > 1)
        {
          System.err.println("ERROR: multiple input files");
          return;
        }
        try
        {
          sr = new FileReader(jArguments.inputFiles.get(0));
        }
        catch (FileNotFoundException fileException)
        {
          System.err.println("%INPUT FILE ERROR: " + fileException.getMessage());
          return;
        }
      }
      if (sr == null) sr = new InputStreamReader(System.in);
      SparcTranslator p = new SparcTranslator(sr);
      programTree = p.program();
      InstanceGenerator gen = new InstanceGenerator(p.sortNameToExpression);
      tc = new TypeChecker(p.sortNameToExpression, p.predicateArgumentSorts, p.constantsMapping, p.curlyBracketTerms, p.definedRecords, gen);
      if (jArguments.inputFiles.size() != 0)
      {
        String fileName=getShortFileName(jArguments.inputFiles.get(0));
        tc.setInputFileName(fileName);
      }
      tc.checkRules((ASTprogramRules) programTree.jjtGetChild(2));
      tc.checkDisplay((ASTdisplay) programTree.jjtGetChild(3));
      
      if(jArguments.printSignature) {
         SortedSignaturePrinter.print(p.predicateArgumentSorts, p.sortNameToExpression, gen);
         return;
      }
      
      Translator tr = new Translator(out, p, gen, jArguments.generateASPWarnings, jArguments.generateClingconWarnings);
      if (jArguments.inputFiles.size() != 0)
      {
        String fileName=getShortFileName(jArguments.inputFiles.get(0));
        tr.setInputFileName(fileName);
      }
      
      translatedProgram.append(tr.translateProgram((ASTprogram) programTree, p.generatingSorts, p.sortRenaming, true));

      if(jArguments.outputFile != null)
      {
        tr.writeTranslatedProgram();
      }
    }
    catch (ParseException pe)
    {
      System.err.println(pe.getMessage());
      return;
    }

  
    
    if(!jArguments.lout)
      System.err.println("program translated");
    ExternalSolver solver = null;
    AnswerSetParser aParser = null;
    try
    {
      if (Settings.getSolver() == ASPSolver.DLV)
      {
        solver = new DLVSolver(translatedProgram.toString());
        aParser = new DLVAnswerSetParser();
      }
      else
      {
        solver = new ClingoSolver(translatedProgram.toString());
        aParser = new ClingoAnswerSetParser();
      }
    }
    catch (
    FileNotFoundException ex)
    {
      System.err.println(ex.getMessage());
    }

    try { 
    if (jArguments.outputAnswerSets)
    {
      new Runner().outputAnswerSets(programTree, solver);
    }
    else
    {
      QueryEngine qe = new QueryEngine(aParser.getAnswerSets(solver.run(true)), tc);
      if(jArguments.query != null)
      {
        qe.answerGroundQuery(jArguments.query);
      }
      else
      {
        qe.run();
      }
    }
}
  catch (IllegalArgumentException pe)
    {
      System.err.println(pe.getMessage());
      return;
    }
  }

  private boolean isInteger(String s)
  {
    if(s.length()< 1)
              return false;
    if (s.length() == 1 && s.charAt(0) == '0') return true;
    if (s.charAt(0) == '0') return false;
    for (int i = 0; i < s.length(); i++)
    {
      if (!Character.isDigit(s.charAt(i))) return false;
    }
    return true;
  }

  /**
  * @return absolute path.
  */
  private static String getShortFileName(String fullPath)
  {
    File file = new File(fullPath);
    return file.getName();
  }

  static final String newLine = System.getProperty("line.separator");

  /**
  * Output help message
  */
  private static void show_usage()
  {
    System.err.println("usage: sparc filename {options}");
    System.err.println(newLine + "Options:" + newLine);
    String message = "-A" + newLine + 
    "    " + newLine + 
    "  Compute answer sets of the loaded program." + newLine + 
    newLine +
    "-n arg" + newLine +
    "  Specify the number of answer sets that need to be displayed." + newLine +
    "  Example: -n=1 will only display one answer set. The default option, -n=0, will "+
    " display all the answer sets " +  
    "-wcon" + newLine + 
    "    " + newLine + 
    "  Show warnings determined by CLP-based algorithm. See type warnings section in the manual." + 
    newLine + 
    "-wasp" + newLine + 
    "    " + newLine + 
    "  Show warnings determined by ASP-based algorithm. See type warnings section in the manual." + newLine + 
    newLine + 
    "-solver arg" + newLine + 
    newLine + 
    "  Specify the solver which will be used for computing answer sets. arg can have two possible values: dlv and clingo. " 
    + newLine + 
    "-solveropts arg" + newLine + 
    newLine + 
    "  Pass command line arguments to the ASP solver (DLV or Clingo)." + newLine + 
    "  " + newLine + 
    "  Example: -solveropts '-pfilter=p'." + newLine + 
    newLine + 
    newLine + 
    "  For the complete list of dlv options, see " + newLine + 
    "  http://www.dlvsystem.com/html/DLV_User_Manual.html " + newLine + 
    newLine + 
    newLine + 
    "  For the complete list of clingo options, see " + newLine + 
    "  http://sourceforge.net/projects/potassco/files/potassco_guide/" + newLine + 
    newLine + 
    "  Note that options '0' and '--shift' are passed to clingo solver by default." + newLine + 
    newLine + 
    "-Help, -H, -help, --Help, --help, -h" + newLine + 
    newLine + 
    "  Show help message." + newLine + 
    newLine + 
    "-o arg" + newLine + 
    newLine + 
    "  Specify the output file where the translated ASP program will be written. arg is the path to the output file." + newLine + 
    "  Note that if the option is not specified, the translated ASP program will not be stored anywhere." + newLine + 
    newLine + 
    "input_file " + newLine + newLine + 
    "  Specify the file where the sparc program is located";
    System.err.println(message);
  }

  /**
  * Add built-in sorts to sort expressions
  */
  public void addBuiltInSorts()
  {
    HashMap < String, ASTsortExpression > builtInSorts = BuiltIn.getBuiltInSorts();
    for (String sortName : builtInSorts.keySet())
    {
      sortNameToExpression.put(sortName, builtInSorts.get(sortName));
    }
  }

  /**
  * Add warning to set of warnings
  */
  public void addWarning(String warning)
  {
    warnings.add(warning);
  }

  public ArrayList < String > getWarnings()
  {
    return warnings;
  }
}

PARSER_END(SparcTranslator)

< DEFAULT, IN_PROGRAM_RULES >
TOKEN :
{
  < MAXINTDIRECTIVE : "#maxint" >
| < CONSTDIRECTIVE : "#const" >
| < SORTDEFKEYWORD : "sorts" ([ "\r", "\t", " ", "\n" ])+ >
| < PREDDEFKEYWORD : "predicates" ([ "\r", "\t", " ", "\n" ])+ >
| < PROGRULDEFKEYWORD : "rules" ([ "\r", "\t", " ", "\n" ])+ > : IN_PROGRAM_RULES
| < DISPLAYKEYWORD : "display" ([ "\r", "\t", " ", "\n" ])+ > 
| < NOT : "not" ([ "\t", "\r", " " ])+ >
| < NOTOP : "not" ([ "\t", "\r", " " ])* "(" >
| < OR : "or" >
| < AND : "and" >
| < IDENTIFIER : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
| < VARIABLE :
    (
      [ "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])*
    | "_"
    ) >
| < NONZERODIGIT : [ "1"-"9" ] >
| < POSITIVE_INTEGER :
    < NONZERODIGIT >
    (
      < ZERO >
    | < NONZERODIGIT >
    )* >
| < ZERO : "0" >
| < PLUS : "+" >
| < MULT : "*" >
| < DIV : "/" >
| < EQ : "=" >
| < EQR : "==" >
| < NOTEQ : "!=" >
| < GT : ">" >
| < GTEQ : ">=" >
| < SM : "<" >
| < SMEQ : "<=" >
| < OP : "(" >
| < CP : ")" >
| < OB : "{" >
| < CB : "}" >
| < ORRSEP : ":-" >
| < CRRSEP : ":+" >
| < WEAKSEP : ":~" >
| < COMMA : "," >
| < DOT : "." >
| < COLON : ":" >
| < SEMICOLON : ";" >
| < DOLLAR : "$" >
| < COMPLEMENT : "~" >
| < HEAD_OR : "|" >
| < AGGREGATE_COUNT_OB : "#count"([ "\t", "\r", "\n"," " ])* "{" >
| < AGGREGATE_SUM_OB : "#sum"([ "\t", "\r", "\n"," " ])* "{" >
| < AGGREGATE_MIN_OB : "#min"([ "\t", "\r", "\n"," " ])* "{" >
| < AGGREGATE_MAX_OB : "#max"([ "\t", "\r", "\n"," " ])* "{" >
| < OSB : "[" >
| < OCB : "]" >
| < POUND_SIGN : "#" >
| < MINIMIZE_OB : "#minimize"([ "\t", "\r", "\n"," " ])* "{" >
| < MAXIMIZE_OB : "#maximize"([ "\t", "\r", "\n"," " ])* "{" >
| < AT : "@" >
}

< IN_PROGRAM_RULES >
TOKEN :
{
  < IDENTIFIER_WITH_OP : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n"," " ])* "(" >
| < NEGATIVE_ATOM_WITH_OP : "-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n"," " ])* "(" >
| < NEGATIVE_SORT_ATOM_WITH_OP : "-#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n"," " ])* "(" >
| < SORT_ATOM : "#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
| < SORT_ATOM_WITH_OP : "#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* "(" >
| < NEGATIVE_SORT_ATOM : "#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
| < NEGATIVE_ATOM : "-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
}

< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >
SKIP :
{
  < SINGLE_LINE_COMMENT :
    "%" (~[ "\n", "\r" ])*
    (
      "\r"
    | "\n"
    | "\r\n"
    )? >
| < SPACE : ([ "\n", "\r", "\t", " " ])+ >
}

< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >
TOKEN :
{
  < MINUS : "-" >
}

SimpleNode program() :
{
  sortNameToExpression = new HashMap < String, ASTsortExpression > ();
  predicateArgumentSorts = new HashMap < String, ArrayList < String >> ();
  crRuleLabels = new HashSet < String > ();
  generatingSorts = new HashSet < String > ();
  constantsMapping = new HashMap < String, Long > ();
  warnings = new ArrayList < String > ();
  curlyBracketTerms = new HashSet < String > ();
  definedRecords= new HashSet < RecordInfo > ();
  sortRenaming = new HashMap<String,String > ();
  SimpleNode disp = null;
}
{
  directives(jjtThis.directives) sortDefinitions() predicateDeclarations() programRules() [disp = display()]< EOF >
  {
    // if there is no display, let's create one consisting
      // of all the predicates in the program!
      if(disp == null)
      {
          HashSet<String > predicatesToDisplay = new HashSet<String > ();
          for (String predName: predicateArgumentSorts.keySet())
          {
              if(!predName.startsWith("#"))
                 predicatesToDisplay.add(predName);
          }
          jjtThis.jjtAddChild(new ASTdisplay(predicatesToDisplay),3);
      }
      
    return jjtThis;
  } 
}

void sortDefinitions() :
{}
{
  (
    < SORTDEFKEYWORD >
    (
      sortDefinition()
    )*
  )
|
  {}
}

void sortDefinition() :
{
  Token t;
  SimpleNode n;
}
{
  < POUND_SIGN > t = < IDENTIFIER > < EQ > n = sortExpression() < DOT >
  {
    if (sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was already defined");
    }
    for (String builtInSortName : BuiltIn.sortNames)
    {
      if (t.image.equals(builtInSortName))
      {
        throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " is built-in and cannot be redefined");
      }
    }
    if (Settings.isEmptySortCheckingEnabled()  &&  EmptySortChecker.isEmpty((ASTsortExpression) n, sortNameToExpression))
    {
      throw new ParseException("sort " + t.image + " defined at line " + t.beginLine + " column " + t.beginColumn + " is empty");
    }
    sortNameToExpression.put(t.image, (ASTsortExpression) n);
  }
}

SimpleNode sortExpression() :
{
  SimpleNode n;
  String s;
}
{
  LOOKAHEAD(2)
  n = setExpression()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
| LOOKAHEAD({ (getToken(1) != null && (getToken(1).image) != null) && (constantsMapping.containsKey(getToken(1).image) || isInteger(getToken(1).image)) })
  n = numericRange()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
| LOOKAHEAD(identifierRange())
  n = identifierRange()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
| n = concatenation()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }

}

SimpleNode setExpression() :
{
  SimpleNode n;
}
{
  n = additiveSetExpression()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
}

SimpleNode multiplicativeSetExpression() :
{
  SimpleNode n;
}
{
  n = unarySetExpression()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
  }
  (
    < MULT > unarySetExpression()
  )*
  {
    return jjtThis;
  }
}

SimpleNode additiveSetExpression() :
{
  jjtThis.image = "+";
  SimpleNode n;
}
{
  n = multiplicativeSetExpression()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
  }
  (
    (
      "+"
      {
        jjtThis.image += "+";
      }
    | "-"
      {
        jjtThis.image += "-";
      }
    )
    multiplicativeSetExpression()
  )*
  {
    return jjtThis;
  }
}

SimpleNode sortName() :
{
  Token t;
}
{
  t = < IDENTIFIER >
  {
    if (!sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("sort " + "#"+ t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
    else
    {
      jjtThis.image = t.image;
      jjtThis.beginLine = t.beginLine;
      jjtThis.beginColumn = t.beginColumn;
    }
    return jjtThis;
  }
}

SimpleNode unarySetExpression() :
{
  Token t;
  SimpleNode n;
}
{
  t = < POUND_SIGN > sortName()
  {
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return jjtThis;
  }
| n = curlyBrackets()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
| t = < OP > setExpression() < CP >
  {
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return jjtThis;
  }

  | n = functionalSymbol() 
  {
    if (!FunctionalSymbolChecker.checkFunctionalSymbolSorts((ASTfunctionalSymbol) n, sortNameToExpression))
    {
      throw new ParseException("the definition of record " + n.image + " at line " + n.beginLine + " column " + n.beginColumn + " has a condition which involves " + "checking less/greater relations on elements of non-basic sorts");
    }
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
}

SimpleNode curlyBrackets() :
{
  Token t;
  SimpleNode child;
}
{
  t = < OB > child = constantTermList() < CB >
  {
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    CurlyBrackets.checkNoKeyWordOccurrences((ASTconstantTermList) child);
    CurlyBrackets.retrieveAllTerms((ASTconstantTermList) child, curlyBracketTerms);
    CurlyBrackets.retrieveAllFunctionalSymbols(jjtThis, definedRecords);
    return jjtThis;
  }
}

void concatenationTermList() #constantTermList :
{}
{
  concatenationTerm()
  (
    < COMMA > concatenationTerm()
  )*
}

SimpleNode constantTermList() :
{}
{
  (
    constantTerm()
  (
    < COMMA > constantTerm()
  )*)*
  {
    return jjtThis;
  }
}

void constantTerm():
{
  Token t1, t2, t3;
  String s;
}
{
  LOOKAHEAD({ (getToken(1) != null && (getToken(1).image) != null) && (constantsMapping.containsKey(getToken(1).image) || isInteger(getToken(1).image)) })
  t1 = number()
  {
    jjtThis.image = t1.image;
  }
| LOOKAHEAD(2)
  t1 = < IDENTIFIER > t3 = < OP > constantTermList() t2 = < CP >
  {  
    jjtThis.image = t1.image + t3.image + " " + t2.image;
  }
| t1 = < IDENTIFIER >
  {
    jjtThis.beginLine = t1.beginLine;
    jjtThis.beginColumn = t1.beginColumn;
    jjtThis.image = t1.image;
  }
}

void concatenationTerm() #constantTerm :
{
  Token t1;
}
{
  LOOKAHEAD({ constantsMapping.containsKey(getToken(1).image) })
  t1 = number()
  {
    jjtThis.image = t1.image;
  }
| t1 = < IDENTIFIER >
  {
    jjtThis.image = t1.image;
  }
}

SimpleNode condition(HashMap < String, Integer > varMap) :
{
  Token t, t1, t2;
}
{
  orCondition(varMap)
  {
    return jjtThis;
  }
}

void orCondition(HashMap < String, Integer > varMap) :
{}
{
  andCondition(varMap)
  (
    < OR > andCondition(varMap)
  )*
}

void andCondition(HashMap < String, Integer > varMap) :
{}
{
  unaryCondition(varMap)
  (
    < AND > unaryCondition(varMap)
  )*
}

void unaryCondition(HashMap < String, Integer > varMap) :
{
  Token t, t3, t4;
}
{
  t3 = var()
  {
    jjtThis.image = varMap.get(t3.image).toString();
  }
  t = rel()
  {
    jjtThis.image += " " + t.image;
  }
  t4 = var()
  {
    jjtThis.image += " " + varMap.get(t4.image).toString();
  }
| < OP > condition(varMap) < CP >
| t = < NOTOP > condition(varMap) < CP >
  {
    jjtThis.image = t.image;
  }
}

SimpleNode functionalSymbol() :
{
  Token t1, t2, t3;
  Token from, to;
  HashMap < String, Integer > map;
  HashSet < Integer > BasicSorts;
  SimpleNode c = null;
}
{
  t1 = < IDENTIFIER > t3 = < OP >
  {}
  map = specialSortExpressionList() t2 = < CP > [ < COLON > c = condition(map) ]
  {
    String recordName = t1.image;
    int arity = jjtThis.jjtGetChild(0).jjtGetNumChildren();
    definedRecords.add(new RecordInfo(recordName,arity)); 
    jjtThis.beginLine = t1.beginLine;
    jjtThis.beginColumn = t1.beginColumn;
    jjtThis.image = t1.image + t3.image + t2.image;
    return jjtThis;
  }
}


Token specialSortExpression() #void :
{
  Token sortToken,t = null;
}
{
  < POUND_SIGN > sortName() [ < OP > t = < VARIABLE > < CP > ]
  {
    return t;
  }
}

HashMap < String, Integer > specialSortExpressionList() #sortExpressionList :
{
  HashMap < String, Integer > variableMapping = new HashMap < String, Integer > ();
  int agr = 0;
  Token t;
}
{
  t = specialSortExpression()
  {
    if (t != null)
    {
      if (variableMapping.containsKey(t.image))
      {
        throw new ParseException("variable " + t.image + " at line " + t.beginLine + ", column " + t.beginColumn + " is used more than once in " + "record definition");
      }
      variableMapping.put(t.image, agr);
    }
    agr++;
  }
  (
    < COMMA > t = specialSortExpression()
    {
      if (t != null)
      {
        if (variableMapping.containsKey(t.image))
        {
          throw new ParseException("variable " + t.image + " at line " + t.beginLine + ", column " + t.beginColumn + " is used more than once in " + "record definition");
        }
        variableMapping.put(t.image, agr);
      }
      agr++;
    }
  )*
  {
    return variableMapping;
  }
}

SimpleNode concatenation() :
{}
{
  (
    < OSB > basicSort() < OCB >
  )+
  {
    return jjtThis;
  }
}

void basicSort() :
{
  SimpleNode se;
  Token t;
  String s;
}
{
  LOOKAHEAD({ (getToken(1) != null && (s = getToken(1).image) != null) && (constantsMapping.containsKey(s) || isInteger(s)) })
  numericRange()
| LOOKAHEAD(identifierRange())
  identifierRange()
| t = < POUND_SIGN > se = sortName()
  {
    if (!sortNameToExpression.containsKey(se.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + "#"+ t.image + "' was not defined");
    }
    ASTsortExpression ex = sortNameToExpression.get(se.image);
    if (!BasicSortChecker.isBasic(ex, sortNameToExpression))
    {
      throw new ParseException("ERROR: Sort '" + "#"+ se.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " is not a basic sort");
    }
  }
| concatenationTermList()
}


SimpleNode identifierRange() :
{
  Token t1, t2;
}
{
  t1 = < IDENTIFIER > < DOT > < DOT > t2 = < IDENTIFIER >
  {
    int errorLine = t1.beginLine;
    int errorColumn = t1.beginColumn;
    if (t1.image.length() > t2.image.length())
    {
      throw new ParseException("ERROR: the length of the first identifier in identifier range should be smaller or equal to the length of the second one " + "at line " + errorLine + ", column " + errorColumn);
    }
    if (t1.image.compareTo(t2.image) > 0)
    {
      throw new ParseException("ERROR: the first identifier in identifier range should be lexicographically smaller or equal to  the second one " + "at line " + errorLine + ", column " + errorColumn);
    }
    jjtThis.image = t1.image + " " + t2.image;
    return jjtThis;
  }
}

SimpleNode numericRange() :
{
  Token from, to;
}
{
  from = number()
  {
    jjtThis.beginLine = from.beginLine;
    jjtThis.beginColumn = from.beginColumn;
  }
  < DOT > < DOT > to = number()
  {
    int fromI = 0;
    int toI = 0;
    try
    {
      fromI = Integer.parseInt(from.image);
      toI = Integer.parseInt(to.image);
    }
    catch (NumberFormatException ex)
    {}
    if (fromI > toI)
    {
      throw new ParseException("ERROR: the first number in numeric  range should be smaller or equal to  the second one " + "at line " + to.beginLine + ", column " + to.beginColumn);
    }
    jjtThis.image = from.image + " " + to.image;
    return jjtThis;
  }
}

Token number() #void :
{
  Token t;
}
{
  t = < POSITIVE_INTEGER >
  {
    int integer = Integer.parseInt(t.image);
	if(integer >  BuiltIn.getMaxInt() )
	{
	    throw new ParseException("ERROR: Integer '" + t.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " is out of range");
    }
    return t;
  }
| t = < ZERO >
  {
    return t;
  }
| t = < NONZERODIGIT >
  {
    return t;
  }
| t = < IDENTIFIER >
  {
    if (!constantsMapping.containsKey(t.image))
    {
      throw new ParseException("ERROR: Constant '" + t.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " was not defined");
      //return t;
    }
    else
    {
      t.image = constantsMapping.get(t.image).toString();
      return t;
    }
  }
}

void predicateDeclarations() :
{}
{
  < PREDDEFKEYWORD >
  (
    predicateDeclaration()
  )*
  {
    HashSet < String > usedPredicateNames = new HashSet < String > ();
    usedPredicateNames.addAll(predicateArgumentSorts.keySet());
    
    for (String sortName : sortNameToExpression.keySet())
    {
      predicateArgumentSorts.put("#" + sortName, new ArrayList < String > ());
      predicateArgumentSorts.get("#" + sortName).add(sortName);
      String nameCandidate = sortName;
      while (usedPredicateNames.contains(nameCandidate))
      {
        nameCandidate += "_";
      }
      usedPredicateNames.add(nameCandidate);
      sortRenaming.put(sortName, nameCandidate);  
    }
  }
}

void predicateDeclaration() :
{
  Token t;
  ArrayList < String > arguments = new ArrayList < String > ();
}
{
  t = < IDENTIFIER >
  {
    if (predicateArgumentSorts.containsKey(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "predicate " + t.image + " was already declared");
    }
    if (BuiltInPredicates.predicateNamesSet.contains(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "predicate " + t.image + " is a built-in predicate");
    }
  }
  < OP >
  (
    arguments = identifierList()
  )?
  {
    predicateArgumentSorts.put(t.image, arguments);
  }
  < CP > < DOT >
}

ArrayList < String > identifierList() :
{
  ArrayList < String > result = new ArrayList < String > ();
  Token t;
}
{
  
  (
    < POUND_SIGN > t = < IDENTIFIER >
  {
    if (!sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + "#"+ t.image + "' was not defined");
    }
    result.add(t.image);
  }
  (
    < COMMA > < POUND_SIGN > t = < IDENTIFIER >
    {
     if (!sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + "#" + t.image + "' was not defined");
    }
      result.add(t.image);
    }
  )*)
  {
    return result;
  }
}

SimpleNode programRules() :
{}
{
  < PROGRULDEFKEYWORD >
  (
    programRule()
  )*
  {
    return jjtThis;
  }
}

SimpleNode programRule() :
{
  Token t;
  SimpleNode n;
  inHead = true;
}
{
  LOOKAHEAD(2)
  t = label()
  {
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    jjtThis.setLabel(t.image);
    if (crRuleLabels.contains(t.image))
    {
      throw new ParseException("cr-rule label " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " occures more then once");
    }
    else
    {
      crRuleLabels.add(t.image);
    }
  }
  n = unlabeledProgramCrRule()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
| n = unlabeledProgramRule()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
}

SimpleNode unlabeledProgramRule() :
{
  Pair n;
  SimpleNode n2;
  Token from, to, sep;
}
{
  LOOKAHEAD(predSymbol() number() < DOT >)
  n = predSymbol() from = number() < DOT > < DOT > to = number() < CP > < DOT > //can be body here after safety fix!
  {
    jjtThis.beginLine = n.first.beginLine;
    jjtThis.beginColumn = n.first.beginColumn;
    jjtThis.image = n.first.image + " " + from.image + " " + to.image;
    inHead = false;
    return jjtThis;
  }
| n2 = head()
  {
    inHead = false;
  }
  sep = exBody()
  {
    jjtThis.image = sep.image;
    jjtThis.beginLine = n2.beginLine;
    jjtThis.beginColumn = n2.beginColumn;
    return jjtThis;
  }
| sep = < ORRSEP >
  {
    inHead = false;
    jjtThis.image = sep.image;
    jjtThis.beginLine = sep.beginLine;
    jjtThis.beginColumn = sep.beginColumn;
  }
  body() < DOT >
  {
    return jjtThis;
  }
| sep = < CRRSEP >
  {
    inHead = false;
    jjtThis.beginLine = sep.beginLine;
    jjtThis.beginColumn = sep.beginColumn;
    jjtThis.image = sep.image;
  }
  body() < DOT >
  {
    return jjtThis;
  }
| sep = < WEAKSEP >
  {
    inHead = false;
    jjtThis.beginLine = sep.beginLine;
    jjtThis.beginColumn = sep.beginColumn;
    jjtThis.image = sep.image;
  }
  body() < DOT > [ constraintParams() ]
  {
    return jjtThis;
  }
}

void constraintParams() :
{
  Token t0;
  Token t1 = null, t2 = null, t3 = null, t4 = null, t5 = null;
  jjtThis.image = "";
}
{
  t0 = < OSB >
  [
    (
      t1 = var()
    | t2 = number()
    )
  ]
  t5 = < COLON >
  [
    (
      t3 = var()
    | t4 = number()
    )
  ]
  < OCB >
  {
    if (t1 == null && t2 == null && t3 == null && t4 == null)
    {
      throw new ParseException("line " + t0.beginLine + ", column " + t0.beginColumn + ": weak constraint paramethers cannot both be empty");
    }
    if (t2 != null)
    {
      jjtThis.image += t2.image;
    }
    else if (t1 != null)
    {
      jjtThis.image += "V";
    }
    jjtThis.image += t5.image;
    if (t4 != null)
    {
      jjtThis.image += t4.image;
    }
    else if (t3 != null)
    {
      jjtThis.image += "V";
    }
  }
}

SimpleNode unlabeledProgramCrRule() :
{
  SimpleNode n;
  Token t;
}
{
  n = head() t = exCrBody()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    jjtThis.image = t.image;
    return jjtThis;
  }
| t = < CRRSEP > body() < DOT >
  {
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    jjtThis.image = t.image;
    return jjtThis;
  }
}

Token label() #void :
{
  Token t;
}
{
  t = < IDENTIFIER > < COLON >
  {
    return t;
  }
}

Token exBody() #void :
{
  Token t;
}
{
  t = exStandartBody()
  {
    return t;
  }
| t = exCrBody()
  {
    return t;
  }
}

Token exStandartBody() #void :
{
  Token t;
}
{
  t = < ORRSEP > body() < DOT >
  {
    return t;
  }
| t = < DOT >
  {
    return new Token(SparcTranslatorConstants.ORRSEP, ":-");
  }
}

Token exCrBody() #void :
{
  Token t;
}
{
  t = < CRRSEP > crBodyWithoutSep()
  {
    return t;
  }
}

void crBodyWithoutSep() #void :
{}
{
  < DOT >
| body() < DOT >
}

SimpleNode head() :
{
  SimpleNode n;
}
{
  LOOKAHEAD(2)
  n = choice_rule()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
| n = disjunction()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
| n = optimize_statement()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
}
        
SimpleNode optimize_statement() :
{
  Token t;
}
{
  t = optimize_ob() [ optimizeParameterList() ] < COLON > [ nonRelAtomList() ] < CB >
  { 
    jjtThis.image = t.image;
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    if (Settings.getSingletonInstance().getSolver() != ASPSolver.Clingo) 
        throw new ParseException("line " + jjtThis.beginLine + ", column " + jjtThis.beginColumn + ": optimization statements are not supported in DLV");
    return jjtThis;
  }
}

Token optimize_ob() #void :
{
  Token t;
}
{
  t = < MINIMIZE_OB >
  {
    return t;
  }
| t = < MAXIMIZE_OB >
  {
    return t;
  }
}

void optimizeParameterList() :
{}
{
    optimizeParameter()
    (
    < COMMA > optimizeParameter()
    )*
}

void nonRelAtomList() :
{}
{
    nonRelAtom()
    (
    < COMMA > nonRelAtom()
    )*
}
        
void optimizeParameter() :
{
    Token t1, t2, t3;
    jjtThis.image = "";
}
{
  LOOKAHEAD(var() < AT > number())
  t1 = var() t2 = <AT> t3 = number()
  {
    jjtThis.image = t1.image + t2.image + t3.image; 
  }
| LOOKAHEAD(number() < AT > number())
  t1 = number() t2 = <AT> t3 = number()
  {
    jjtThis.image = t1.image + t2.image + t3.image;
  }
| LOOKAHEAD(var())
  t1 = var()
  {
    jjtThis.image = t1.image;
  }
| LOOKAHEAD(number())
  t1 = number()
  {
    jjtThis.image = t1.image;
  }
}

SimpleNode disjunction() :
{
  SimpleNode n;
}
{
  n = nonRelAtom()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
  }
  (
    < HEAD_OR > nonRelAtom()
  )*
  {
    return jjtThis;
  }
}

SimpleNode choice_rule() :
{
  SimpleNode n1 = null;
  Token t;
}
{
  [
    n1 = arithmeticTerm()
    [
      t = rel()
      {
        jjtThis.image = "L" + t.image;
      }
    ]
  ]
  t = < OB > choice_elements() < CB >
  [
    [
      t = rel()
      {
        jjtThis.image += " R" + t.image;
      }
    ]
    arithmeticTerm()
  ]
  {
    if (n1 != null)
    {
      jjtThis.beginLine = n1.beginLine;
      jjtThis.beginColumn = n1.beginColumn;
    }
    else
    {
      jjtThis.beginLine = t.beginLine;
      jjtThis.beginColumn = t.beginColumn;
    }
    if (Settings.getSingletonInstance().getSolver() != ASPSolver.Clingo) 
    throw new ParseException("line " + jjtThis.beginLine + ", column " + jjtThis.beginColumn + ": choice rules are not supported in DLV");
    return jjtThis;
  }
}

void choice_elements() :
{}
{
  choice_element()
  (
    < SEMICOLON > choice_element()
  )*
}

void choice_element() :
{
  SimpleNode n;
}
{
  n = nonRelAtom() [ < COLON > extendedSimpleAtomList() ]
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
  }
}

void extendedSimpleAtomList() :
{}
{
  simpleAtom()
  (
    < COMMA > simpleAtom()
  )*
}

void body() :
{}
{
  atom()
  (
    < COMMA > atom()
  )*
}

Token var() :
{
  Token t;
}
{
  t = < VARIABLE >
  {
    jjtThis.image = t.image;
    jjtThis.setOriginalImage(t.image);
    return t;
  }
}

SimpleNode nonRelAtom() :
{
  SimpleNode tList = null;
  Pair n;
}
{
  n = predSymbol()
  {
    jjtThis.beginLine = n.first.beginLine;
    jjtThis.beginColumn = n.first.beginColumn;
  }
  [
    tList = termList()
    {
      if (!n.second && tList != null)
      {
        throw new ParseException("ERROR:( expected at line " + tList.beginLine + " column " + tList.beginColumn);
      }
    }
    < CP >
  ]
  {
    ASTpredSymbol predS = (ASTpredSymbol) n.first;
    if (predS.hasPoundSign && (tList == null || tList.jjtGetNumChildren() != 1) && !inDisplay)
    {
      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " must have exactly one argument");
    }

    if (predS.hasPoundSign && tList != null && tList.jjtGetNumChildren() > 1 && inDisplay)
    {
      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " cannot have more than one argument");
    }

    
    return jjtThis;
  }
}

void simpleAtom() :
{
  SimpleNode n;
  Token t;
}
{
  LOOKAHEAD(symbolicTerm() rel() symbolicTerm())
  symbolicTerm() t = rel() symbolicTerm()
  {
    jjtThis.image = t.image;
  }
| LOOKAHEAD(symbolicTerm() rel() var())
  symbolicTerm() t = rel() var()
  {
    jjtThis.image = t.image;
  }
| LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())
  arithmeticTerm() t = rel() arithmeticTerm()
  {
    jjtThis.image = t.image;
  }
| LOOKAHEAD(var() rel() symbolicTerm())
  var() t = rel() symbolicTerm()
  {
    jjtThis.image = t.image;
  }
| LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())
  arithmeticTerm() t = eqrel() symbolicTerm()
  {
    jjtThis.image = t.image;
  }
| LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())
  symbolicTerm() t = eqrel() arithmeticTerm()
  {
    jjtThis.image = t.image;
  }
| n = extendedNonRelAtom()
  {
    jjtThis.image = n.image;
  }
}

SimpleNode extendedNonRelAtom() :
{
  Token t;
  jjtThis.image = "";
  SimpleNode tList = null;
  Pair n;
}
{
  [
    t = < NOT >
    {
      jjtThis.image = t.image;
    }
  ]
  n = predSymbol()
  [
    tList = termList()
    {
      if (!n.second && tList != null)
      {
        throw new ParseException("ERROR:( expected at line " + tList.beginLine + " column " + tList.beginColumn);
      }
    }
    < CP >
  ]
  {
    ASTpredSymbol predS = (ASTpredSymbol) n.first;
    if (predS.hasPoundSign && (tList == null || tList.jjtGetNumChildren() != 1))
    {
      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " must have exactly one argument");
    }
    return jjtThis;
  }
}

SimpleNode addOp() #void :
{
  Token t;
  SimpleNode n = new SimpleNode(0);
}
{
  t = < PLUS >
  {
    n.image = t.image;
    return n;
  }
| t = < MINUS >
  {
    n.image = t.image;
    return n;
  }
}

SimpleNode multOp() #void :
{
  Token t;
  SimpleNode n = new SimpleNode(0);
}
{
  t = < MULT >
  {
    n.image = t.image;
    return n;
  }
| t = < DIV >
  {
    n.image = t.image;
    return n;
  }
}

SimpleNode arithmeticTerm() :
{
  SimpleNode n;
}
{
  n = additiveArithmeticTerm()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
}

SimpleNode atomicArithmeticTerm() :
{
  Token t;
 
}
{
  
  LOOKAHEAD({  (getToken(1) != null && getToken(1).image != null) && (constantsMapping.containsKey(getToken(1).image ) || isInteger(getToken(1).image )) })
  t = number()
  {
    jjtThis.image = t.image;
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return jjtThis;
  }
| t = var()
  {
    jjtThis.image = t.image;
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return jjtThis;
  }
| t = < OP > arithmeticTerm() < CP >
  {
    jjtThis.image = t.image;
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return jjtThis;
  }
}

SimpleNode additiveArithmeticTerm() :
{
  SimpleNode n;
  jjtThis.image = "+";
}
{
  n = multiplicativeArithmeticTerm()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
  }
  (
    n = addOp()
    {
      jjtThis.image += n.image;
    }
    multiplicativeArithmeticTerm()
  )*
  {
    return jjtThis;
  }
}

SimpleNode multiplicativeArithmeticTerm() :
{
  SimpleNode n;
  jjtThis.image = "";
}
{
  n = atomicArithmeticTerm()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
  }
  (
    n = multOp()
    {
      jjtThis.image += n.image;
    }
    atomicArithmeticTerm()
  )*
  {
    return jjtThis;
  }
}

SimpleNode symbolicFunction() :
{
  Token t;
}
{
  t = < IDENTIFIER_WITH_OP >
  {
    jjtThis.image = t.image;
    jjtThis.beginColumn = t.beginColumn;
    jjtThis.beginLine = t.beginLine;
    return jjtThis;
  }
}


SimpleNode symbolicConstant() :
{
  Token t;
}
{
  t = < IDENTIFIER >
  {
    jjtThis.image = t.image;
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return jjtThis;
  }
}

SimpleNode symbolicTerm() :
{
  SimpleNode n;
}
{
  n = symbolicConstant()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
| n = symbolicFunction()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
  }
  termList() < CP >
  {
    return jjtThis;
  }
}

SimpleNode term() :
{
  SimpleNode n;
  Token t;
  jjtThis.image = "";
}
{

 LOOKAHEAD(var() (< CP >
| < COMMA > | < COLON >))
  t = var()
  {
    //System.out.println("t.image");
    jjtThis.image = t.image;
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return jjtThis;
  }
| 
  LOOKAHEAD(2)
  n = arithmeticTerm()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
| n = symbolicTerm()
  {
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
    return jjtThis;
  }
}

SimpleNode termList() :
{
  SimpleNode t;
}
{
  t = term()
  {
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
  }
  (
    < COMMA > term()
  )*
  {
    return jjtThis;
  }
}

Token rel() #void :
{
  Token t;
}
{
  t = < EQ >
  {
    return t;
  }
| t = < NOTEQ >
  {
    return t;
  }
| t = < GT >
  {
    return t;
  }
| t = < GTEQ >
  {
    return t;
  }
| t = < SM >
  {
    return t;
  }
| t = < SMEQ >
  {
    return t;
  }
| t = < EQR >
  {
    return t;
  }
}

Token eqrel() #void :
{
  Token t;
}
{
  t = < EQ >
  {
    return t;
  }
| t = < NOTEQ >
  {
    return t;
  }
}

Pair predSymbol() :
{
  Token t, poundSign = null;
}
{
  t = < IDENTIFIER >
  {
    jjtThis.image = t.image;
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, false);
  }
| t = < IDENTIFIER_WITH_OP >
  {
    jjtThis.image = t.image.substring(0, t.image.length() - 1);
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, true);
  }

| 
t = < SORT_ATOM_WITH_OP >
  {
    jjtThis.setPoundSign(true);
    if (inHead)
    
    {
      throw new ParseException("sort name " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
    }
    String sort = t.image.substring(0, t.image.length() - 1);
    if (!predicateArgumentSorts.containsKey(sort))
    {
      throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
    generatingSorts.add(t.image.substring(1, t.image.length()-1));
    jjtThis.image = t.image.substring(1, t.image.length() - 1);
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, true);
  }

| t = < NEGATIVE_ATOM_WITH_OP >
  {
    jjtThis.negative = true;
    jjtThis.image = t.image.substring(1, t.image.length() - 1);
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, true);
  }
| t = < NEGATIVE_ATOM >
  {
    jjtThis.negative = true;
    jjtThis.image = t.image.substring(1, t.image.length());
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, false);
  }
| t = < NEGATIVE_SORT_ATOM_WITH_OP >
  {
    jjtThis.setPoundSign(true);
    if (inHead)
    {
      throw new ParseException("sort name " + t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
    }
    sort = t.image.substring(2, t.image.length() - 1);
    if (!predicateArgumentSorts.containsKey(sort))
    {
      throw new ParseException("sort " +  t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
   
    jjtThis.negative = true;
    jjtThis.image = t.image.substring(2, t.image.length() - 1);
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, true);
  }

  | t = < SORT_ATOM >
  {
    jjtThis.setPoundSign(true);
    if (inHead)
    {
      throw new ParseException("sort name " + t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
    }
    sort = t.image;
    if (!predicateArgumentSorts.containsKey(sort))
    {
      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
    generatingSorts.add(t.image.substring(1));
    jjtThis.negative = false;
    jjtThis.image = t.image.substring(1);
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, false);
  }

  | t = < NEGATIVE_SORT_ATOM >
  {
    jjtThis.setPoundSign(true);
    if (inHead)
    {
      throw new ParseException("sort name " + t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
    }
    sort = t.image.substring(2);
    if (!predicateArgumentSorts.containsKey(sort))
    {
      throw new ParseException("sort " + t.image.substring(1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
    jjtThis.negative = true;
    jjtThis.image = t.image.substring(2);
    jjtThis.beginLine = t.beginLine;
    jjtThis.beginColumn = t.beginColumn;
    return new Pair(jjtThis, false);
  }

  
}

void atom() :
{
  Token t1;
}
{
  LOOKAHEAD([ arithmeticTerm() rel() ] aggregateFunction())
  aggregate()
| LOOKAHEAD(symbolicTerm() rel() symbolicTerm())
  symbolicTerm() t1 = rel() symbolicTerm()
  {
    jjtThis.image = t1.image;
  }
| LOOKAHEAD(symbolicTerm() rel() var())
  symbolicTerm() t1 = rel() var()
  {
    jjtThis.image = t1.image;
  }
| LOOKAHEAD(var() rel() symbolicTerm())
  var() t1 = rel() symbolicTerm()
  {
    jjtThis.image = t1.image;
  }
| LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())
  arithmeticTerm() t1 = eqrel() symbolicTerm()
  {
    jjtThis.image = t1.image;
  }
| LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())
  symbolicTerm() t1 = eqrel() arithmeticTerm()
  {
    jjtThis.image = t1.image;
  }
| LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())
  arithmeticTerm() t1 = rel() arithmeticTerm()
  {
    jjtThis.image = t1.image;
  }
| extendedNonRelAtom()
}

void aggregate() :
{
  Token t1 = null, t2 = null;
  jjtThis.image = "";
}
{
  [ arithmeticTerm() t1 = rel() ] aggregateFunction() aggregateElements() < CB > [ t2 = rel() arithmeticTerm() ]
  {
    if (t1 != null)
    {
      jjtThis.image += "L" + t1.image;
    }
    if (t2 != null)
    {
      jjtThis.image += "R" + t2.image;
    }
  }
}

void aggregateElements() :
{}
{
  aggregateElement()
  (
    < SEMICOLON > aggregateElement()
  )*
}

void aggregateElement():
{
  SimpleNode n;
}
{
  (
    n = term()
  )
  (
    < COMMA >
      term()
  )*
   < COLON > extendedSimpleAtomList() 
  {
    for(int i=0; i<jjtThis.jjtGetNumChildren(); i++)
    {
        SimpleNode child = (SimpleNode) jjtThis.jjtGetChild(i);
        if(child.getId() == SparcTranslatorTreeConstants.JJTTERM)
        {
           ASTterm term = (ASTterm) child;
           if(!term.isGround() && !term.isVariable())
           {
             throw new ParseException("the term at line " + n.beginLine + " column " + n.beginColumn + " is not ground and is not a variable ");
           }
        }
    }
    jjtThis.beginLine = n.beginLine;
    jjtThis.beginColumn = n.beginColumn;
  }
}

void aggregateFunction() :
{
  Token t;
}
{
  t = < AGGREGATE_COUNT_OB >
  {
    jjtThis.image = t.image;
  }
| t = < AGGREGATE_MAX_OB >
  {
    jjtThis.image = t.image;
  }
| t = < AGGREGATE_MIN_OB >
  {
    jjtThis.image = t.image;
  }
| t = < AGGREGATE_SUM_OB >
  {
    jjtThis.image = t.image;
  }
}

void atomSequence() :
{}
{
  atom()
  (
    < COMMA > atom()
  )*
}


void directives(ArrayList < String > directives) #void :
{}
{
  (
    directive(directives)
  )*
  {
    addBuiltInSorts();
  }
}

void directive(ArrayList < String > directives) #void :
{
  Token t, t1, t2, t3, t4;
}
{
  t = < MAXINTDIRECTIVE > t1 = < EQ > t2 = number() t3 = < DOT >
  {
    Integer value = Integer.parseInt(t2.image);
    BuiltIn.setMaxInt(value);
  }
| t = < CONSTDIRECTIVE > t1 = < IDENTIFIER > t2 = < EQ > t3 = number() t4 = < DOT >
  {
    directives.add(t.image + " " + t1.image + t2.image + t3.image + t4.image);
    constantsMapping.put(t1.image, Long.parseLong(t3.image));
  }
}

SimpleNode display():
{
  inDisplay = true;
}
{
  < DISPLAYKEYWORD >
    (
      nonRelAtom() < DOT >
    )*
    {
      return jjtThis;
    }
}
