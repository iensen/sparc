/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Sparc.jj */
/*@egen*///TODO: change extendedNonRelAtom to extendedAtom.
options
{
  BUILD_PARSER = true;
  STATIC = false;
  OUTPUT_DIRECTORY = "/home/iensen/Projects/sparc/src/project/src/parser";
               
}

PARSER_BEGIN(SparcTranslator)
package parser;
import java.io.*;
import sorts.*;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;
import java.util.HashSet;
import java.util.Arrays;
import java.util.Set;
import translating.Translator;
import typechecking.TypeChecker;
import typechecking.RecordInfo;
import translating.InstanceGenerator;
import com.beust.jcommander.Parameter;
import com.beust.jcommander.JCommander;
import com.beust.jcommander.ParameterException;
import querying.QueryEngine;
import querying.parsing.AnswerSets.AnswerSetParser;
import querying.parsing.AnswerSets.ClingoAnswerSetParser;
import querying.parsing.AnswerSets.DLVAnswerSetParser;
import configuration.ASPSolver;
import externaltools.ClingoSolver;
import externaltools.DLVSolver;
import externaltools.ExternalSolver;
import configuration.Settings;
import solving.Runner;
import signatureprinting.SortedSignaturePrinter;

class Arguments
{
  @ Parameter(description = "Input files") List < String > inputFiles = new ArrayList < String > ();
  @ Parameter(names = "-wasp", description = "Generate ASP debugging rules") boolean generateASPWarnings = false;
  @ Parameter(names = "-wcon", description = "Generate warnings based on translation to clingcon") boolean generateClingconWarnings = false;
  @ Parameter(names =
  {
    "-Help", "-H", "-help", "--Help", "--help", "-h"
  }
  , help = true) boolean help;
  @ Parameter(names = "--disable-empty-sort-check", description = "Disable checking of sorts for being non-empty") boolean noEmptyCheck = false;
  @ Parameter(names = "--print-signature", description = "Print the signature in JSON format") boolean printSignature = false;
  @ Parameter(names = "-o", description = "Output file") String outputFile = null;
  @ Parameter(names = "-q", description = "Query") String query = null;
  @ Parameter(names = "-A", description = "outputAnswerSets") boolean outputAnswerSets = false;
  @ Parameter(names = "-web", description = "special things for online ide") boolean web = false;
  @ Parameter(names = "-loutput", description = "output answer sets in L format") boolean lout = false;
  @ Parameter(names = "-solver", description = "selected solver") String solver = null;
  @ Parameter(names = "-solveropts", description = "options passed to internal solver")
    String solverOpts = null;   
  @ Parameter(names = "-n", description = "options passed to internal solver") int numberOfAnswerSets = 0;
 }

class Pair
{
  SimpleNode first;
  boolean second;

  public Pair(SimpleNode first, boolean second)
  {
    this.first = first;
    this.second = second;
  }
}

@ SuppressWarnings("all") public class SparcTranslator/*@bgen(jjtree)*/implements SparcTranslatorTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected JJTSparcTranslatorState jjtree = new JJTSparcTranslatorState();

/*@egen*/
  // mapping from sort names to sort expressions assigned to the sorts
  public HashMap < String, ASTsortExpression > sortNameToExpression;

  // mapping from predicate names to a list of names of sorts describing
  // arguments
  public HashMap < String, ArrayList < String >> predicateArgumentSorts;

  // labels of cr-rules
  public HashSet < String > crRuleLabels;

  //sort occurred explicitly in the program
  public HashSet < String > generatingSorts;

  // mapping from constant names to their values.
  public HashMap < String, Long > constantsMapping;

  // warnings found during the translation
  private ArrayList < String > warnings;

  // set of all terms occurring in curly brackets and their subterms
  public HashSet < String > curlyBracketTerms;

  // set of all defined records
  public HashSet<RecordInfo> definedRecords;

  // hashmap from original sort names to sort names which match ASP syntax

  public HashMap<String, String > sortRenaming;


  // controlling the parsing
  boolean inHead = false;
  boolean inDisplay = true;

  int anonSortId = 0;
  /**
  * Remove from args all 
  */
  private static HashSet < String > fetchOptions(String [] args)
  {
    HashSet < String > options = new HashSet < String > ();
    for (int i = 0; i < args.length; i++)
    {
      if (args [i].startsWith("--"))
      {
        options.add(args [i]);
        args = ArrayUtils.removeNthElement(args, i);
        i--;
      }
    }
    return options;
  }

  private static final Set < String > supportedSolvers = new HashSet < String > (Arrays.asList("clingo", "dlv"));

  public static void main(String [] args)
  {
  
    Arguments jArguments = new Arguments();
    try
    {
      new JCommander(jArguments, args);
    }
    catch (ParameterException ex)
    {
      System.err.println("ERROR: " + ex.getMessage());
      return;
    }

    if(!jArguments.lout)
        System.err.println("SPARC  V2.57");
   
    if (jArguments.help)
    {
      show_usage();
      return;
    }
    
    if(!jArguments.outputAnswerSets && jArguments.numberOfAnswerSets != 0)
    {
           System.err.println("ERROR: Option -n=" + jArguments.numberOfAnswerSets + " cannot be used without option -A");
           return;
    }
    
    if (jArguments.solver != null)
    {
      if (!supportedSolvers.contains(jArguments.solver))
      {
        System.err.println("Unknown solver: " + jArguments.solver);
        return;
      }
    }
    if (jArguments.solver != null)
    {
      if (jArguments.solver.equals("clingo")) 
         Settings.getSingletonInstance().setSolver(ASPSolver.Clingo);
      else if (jArguments.solver.equals("dlv"))
         Settings.getSingletonInstance().setSolver(ASPSolver.DLV);
    }

    Settings.setLOutputFormat(jArguments.lout);
    Settings.setWebMode(jArguments.web);
    Settings.setEmptySortCheckingDisabled(jArguments.noEmptyCheck);
    Settings.setRequiredNumberOfComputedAnswerSets(jArguments.numberOfAnswerSets);
    
    if (jArguments.solverOpts != null)
    {
      System.err.println("The option -solveropts is deprecated. Use option -n to specify the number" + 
      "of answer sets that need to be displayed and display statements to specify which predicates need to be displayed.");
      return;
    }

    if(jArguments.query != null)
    {
      Settings.setCommandLineQuery(jArguments.query);
    }
 
    Reader sr = null;
    Writer out = null;
    if (jArguments.outputFile != null)
    {
      if (new File(jArguments.outputFile).exists() && !new File(jArguments.outputFile).isDirectory())
      {
        System.err.println("the output file already exists , do you want to overwrite it? y/n:");
        char rep;
        try
        {
          InputStreamReader converter = new InputStreamReader(System.in);
		  BufferedReader in = new BufferedReader(converter);
          rep =in.readLine().charAt(0); 
        }
        catch (IOException e)
        {
          e.printStackTrace();
          return;
        }
        if (rep != 'y' && rep != 'Y')
        {
          return;
        }
      }
      try
      {
        out = new FileWriter(jArguments.outputFile);
      }
      catch (IOException e)
      {
        e.printStackTrace();
      }
    }
    
    TypeChecker tc = null;
    StringBuilder translatedProgram = new StringBuilder();
    SimpleNode programTree = null;
    try
    {
      if (jArguments.inputFiles != null && jArguments.inputFiles.size() != 0)
      {
        if (jArguments.inputFiles.size() > 1)
        {
          System.err.println("ERROR: multiple input files");
          return;
        }
        try
        {
          sr = new FileReader(jArguments.inputFiles.get(0));
        }
        catch (FileNotFoundException fileException)
        {
          System.err.println("%INPUT FILE ERROR: " + fileException.getMessage());
          return;
        }
      }
      if (sr == null) sr = new InputStreamReader(System.in);
      SparcTranslator p = new SparcTranslator(sr);
      programTree = p.program();
      InstanceGenerator gen = new InstanceGenerator(p.sortNameToExpression);
      tc = new TypeChecker(p.sortNameToExpression, p.predicateArgumentSorts, p.constantsMapping, p.curlyBracketTerms, p.definedRecords, gen);
      if (jArguments.inputFiles.size() != 0)
      {
        String fileName=getShortFileName(jArguments.inputFiles.get(0));
        tc.setInputFileName(fileName);
      }
      tc.checkRules((ASTprogramRules) programTree.jjtGetChild(2));
      tc.checkDisplay((ASTdisplay) programTree.jjtGetChild(3));
      
      if(jArguments.printSignature) {
         SortedSignaturePrinter.print(p.predicateArgumentSorts, p.sortNameToExpression, gen);
         return;
      }
      
      Translator tr = new Translator(out, p, gen, jArguments.generateASPWarnings, jArguments.generateClingconWarnings);
      if (jArguments.inputFiles.size() != 0)
      {
        String fileName=getShortFileName(jArguments.inputFiles.get(0));
        tr.setInputFileName(fileName);
      }
      
      translatedProgram.append(tr.translateProgram((ASTprogram) programTree, p.generatingSorts, p.sortRenaming, true));

      if(jArguments.outputFile != null)
      {
        tr.writeTranslatedProgram();
      }
    }
    catch (ParseException pe)
    {
      System.err.println(pe.getMessage());
      return;
    }

  
    
    if(!jArguments.lout)
      System.err.println("program translated");
    ExternalSolver solver = null;
    AnswerSetParser aParser = null;
    try
    {
      if (Settings.getSolver() == ASPSolver.DLV)
      {
        solver = new DLVSolver(translatedProgram.toString());
        aParser = new DLVAnswerSetParser();
      }
      else
      {
        solver = new ClingoSolver(translatedProgram.toString());
        aParser = new ClingoAnswerSetParser();
      }
    }
    catch (
    FileNotFoundException ex)
    {
      System.err.println(ex.getMessage());
    }

    try { 
    if (jArguments.outputAnswerSets)
    {
      new Runner().outputAnswerSets(programTree, solver);
    }
    else
    {
      QueryEngine qe = new QueryEngine(aParser.getAnswerSets(solver.run(true)), tc);
      if(jArguments.query != null)
      {
        qe.answerGroundQuery(jArguments.query);
      }
      else
      {
        qe.run();
      }
    }
}
  catch (IllegalArgumentException pe)
    {
      System.err.println(pe.getMessage());
      return;
    }
  }

  private boolean isInteger(String s)
  {
    if(s.length()< 1)
              return false;
    if (s.length() == 1 && s.charAt(0) == '0') return true;
    if (s.charAt(0) == '0') return false;
    for (int i = 0; i < s.length(); i++)
    {
      if (!Character.isDigit(s.charAt(i))) return false;
    }
    return true;
  }

  /**
  * @return absolute path.
  */
  private static String getShortFileName(String fullPath)
  {
    File file = new File(fullPath);
    return file.getName();
  }

  static final String newLine = System.getProperty("line.separator");

  /**
  * Output help message
  */
  private static void show_usage()
  {
    System.err.println("usage: sparc filename {options}");
    System.err.println(newLine + "Options:" + newLine);
    String message = "-A" + newLine + 
    "    " + newLine + 
    "  Compute answer sets of the loaded program." + newLine + 
    newLine +
    "-n arg" + newLine +
    "  Specify the number of answer sets that need to be displayed." + newLine +
    "  Example: -n=1 will only display one answer set. The default option, -n=0, will "+
    " display all the answer sets " +  
    "-wcon" + newLine + 
    "    " + newLine + 
    "  Show warnings determined by CLP-based algorithm. See type warnings section in the manual." + 
    newLine + 
    "-wasp" + newLine + 
    "    " + newLine + 
    "  Show warnings determined by ASP-based algorithm. See type warnings section in the manual." + newLine + 
    newLine + 
    "-solver arg" + newLine + 
    newLine + 
    "  Specify the solver which will be used for computing answer sets. arg can have two possible values: dlv and clingo. " 
    + newLine + 
    "-solveropts arg" + newLine + 
    newLine + 
    "  Pass command line arguments to the ASP solver (DLV or Clingo)." + newLine + 
    "  " + newLine + 
    "  Example: -solveropts '-pfilter=p'." + newLine + 
    newLine + 
    newLine + 
    "  For the complete list of dlv options, see " + newLine + 
    "  http://www.dlvsystem.com/html/DLV_User_Manual.html " + newLine + 
    newLine + 
    newLine + 
    "  For the complete list of clingo options, see " + newLine + 
    "  http://sourceforge.net/projects/potassco/files/potassco_guide/" + newLine + 
    newLine + 
    "  Note that options '0' and '--shift' are passed to clingo solver by default." + newLine + 
    newLine + 
    "-Help, -H, -help, --Help, --help, -h" + newLine + 
    newLine + 
    "  Show help message." + newLine + 
    newLine + 
    "-o arg" + newLine + 
    newLine + 
    "  Specify the output file where the translated ASP program will be written. arg is the path to the output file." + newLine + 
    "  Note that if the option is not specified, the translated ASP program will not be stored anywhere." + newLine + 
    newLine + 
    "input_file " + newLine + newLine + 
    "  Specify the file where the sparc program is located";
    System.err.println(message);
  }

  /**
  * Add built-in sorts to sort expressions
  */
  public void addBuiltInSorts()
  {
    HashMap < String, ASTsortExpression > builtInSorts = BuiltIn.getBuiltInSorts();
    for (String sortName : builtInSorts.keySet())
    {
      sortNameToExpression.put(sortName, builtInSorts.get(sortName));
    }
  }

  /**
  * Add warning to set of warnings
  */
  public void addWarning(String warning)
  {
    warnings.add(warning);
  }

  public ArrayList < String > getWarnings()
  {
    return warnings;
  }
}

PARSER_END(SparcTranslator)

< DEFAULT, IN_PROGRAM_RULES >
TOKEN :
{
  < MAXINTDIRECTIVE : "#maxint" >
| < CONSTDIRECTIVE : "#const" >
| < SORTDEFKEYWORD : "sorts" ([ "\r", "\t", " ", "\n" ])+ >
| < PREDDEFKEYWORD : "predicates" ([ "\r", "\t", " ", "\n" ])+ >
| < PROGRULDEFKEYWORD : "rules" ([ "\r", "\t", " ", "\n" ])+ > : IN_PROGRAM_RULES
| < DISPLAYKEYWORD : "display" ([ "\r", "\t", " ", "\n" ])+ > 
| < NOT : "not" ([ "\t", "\r", " " ])+ >
| < NOTOP : "not" ([ "\t", "\r", " " ])* "(" >
| < OR : "or" >
| < AND : "and" >
| < IDENTIFIER : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
| < VARIABLE :
    (
      [ "A"-"Z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])*
    | "_"
    ) >
| < NONZERODIGIT : [ "1"-"9" ] >
| < POSITIVE_INTEGER :
    < NONZERODIGIT >
    (
      < ZERO >
    | < NONZERODIGIT >
    )* >
| < ZERO : "0" >
| < PLUS : "+" >
| < MULT : "*" >
| < DIV : "/" >
| < EQ : "=" >
| < EQR : "==" >
| < NOTEQ : "!=" >
| < GT : ">" >
| < GTEQ : ">=" >
| < SM : "<" >
| < SMEQ : "<=" >
| < OP : "(" >
| < CP : ")" >
| < OB : "{" >
| < CB : "}" >
| < ORRSEP : ":-" >
| < CRRSEP : ":+" >
| < WEAKSEP : ":~" >
| < COMMA : "," >
| < DOT : "." >
| < COLON : ":" >
| < SEMICOLON : ";" >
| < DOLLAR : "$" >
| < COMPLEMENT : "~" >
| < HEAD_OR : "|" >
| < AGGREGATE_COUNT_OB : "#count"([ "\t", "\r", "\n"," " ])* "{" >
| < AGGREGATE_SUM_OB : "#sum"([ "\t", "\r", "\n"," " ])* "{" >
| < AGGREGATE_MIN_OB : "#min"([ "\t", "\r", "\n"," " ])* "{" >
| < AGGREGATE_MAX_OB : "#max"([ "\t", "\r", "\n"," " ])* "{" >
| < OSB : "[" >
| < OCB : "]" >
| < POUND_SIGN : "#" >
| < MINIMIZE_OB : "#minimize"([ "\t", "\r", "\n"," " ])* "{" >
| < MAXIMIZE_OB : "#maximize"([ "\t", "\r", "\n"," " ])* "{" >
| < AT : "@" >
}

< IN_PROGRAM_RULES >
TOKEN :
{
  < IDENTIFIER_WITH_OP : [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n"," " ])* "(" >
| < NEGATIVE_ATOM_WITH_OP : "-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n"," " ])* "(" >
| < NEGATIVE_SORT_ATOM_WITH_OP : "-#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* ([ "\t", "\r", "\n"," " ])* "(" >
| < SORT_ATOM : "#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
| < SORT_ATOM_WITH_OP : "#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* "(" >
| < NEGATIVE_SORT_ATOM : "#" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
| < NEGATIVE_ATOM : "-" [ "a"-"z" ] ([ "a"-"z", "A"-"Z", "0"-"9", "_" ])* >
}

< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >
SKIP :
{
  < SINGLE_LINE_COMMENT :
    "%" (~[ "\n", "\r" ])*
    (
      "\r"
    | "\n"
    | "\r\n"
    )? >
| < SPACE : ([ "\n", "\r", "\t", " " ])+ >
}

< DEFAULT, IN_PROGRAM_RULES, IN_REGULAREXPRESSIONSEQUENCE >
TOKEN :
{
  < MINUS : "-" >
}

SimpleNode program() :
{/*@bgen(jjtree) program */
  ASTprogram jjtn000 = new ASTprogram(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  sortNameToExpression = new HashMap < String, ASTsortExpression > ();
  predicateArgumentSorts = new HashMap < String, ArrayList < String >> ();
  crRuleLabels = new HashSet < String > ();
  generatingSorts = new HashSet < String > ();
  constantsMapping = new HashMap < String, Long > ();
  warnings = new ArrayList < String > ();
  curlyBracketTerms = new HashSet < String > ();
  definedRecords= new HashSet < RecordInfo > ();
  sortRenaming = new HashMap<String,String > ();
  SimpleNode disp = null;
}
{/*@bgen(jjtree) program */
  try {
/*@egen*/
  directives(jjtn000.directives) sortDefinitions() predicateDeclarations() programRules() [disp = display()]< EOF >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    // if there is no display, let's create one consisting
      // of all the predicates in the program!
      if(disp == null)
      {
          HashSet<String > predicatesToDisplay = new HashSet<String > ();
          for (String predName: predicateArgumentSorts.keySet())
          {
              if(!predName.startsWith("#"))
                 predicatesToDisplay.add(predName);
          }
          jjtn000.jjtAddChild(new ASTdisplay(predicatesToDisplay),3);
      }
      
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ 
}

void sortDefinitions() :
{/*@bgen(jjtree) sortDefinitions */
  ASTsortDefinitions jjtn000 = new ASTsortDefinitions(JJTSORTDEFINITIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) sortDefinitions */
  try {
/*@egen*/
  (
    < SORTDEFKEYWORD >
    (
      sortDefinition()
    )*
  )
|/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {}/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void sortDefinition() :
{/*@bgen(jjtree) sortDefinition */
  ASTsortDefinition jjtn000 = new ASTsortDefinition(JJTSORTDEFINITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  SimpleNode n;
}
{/*@bgen(jjtree) sortDefinition */
  try {
/*@egen*/
  < POUND_SIGN > t = < IDENTIFIER > < EQ > n = sortExpression() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if (sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was already defined");
    }
    for (String builtInSortName : BuiltIn.sortNames)
    {
      if (t.image.equals(builtInSortName))
      {
        throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " is built-in and cannot be redefined");
      }
    }
    if (Settings.isEmptySortCheckingEnabled()  &&  EmptySortChecker.isEmpty((ASTsortExpression) n, sortNameToExpression))
    {
      throw new ParseException("sort " + t.image + " defined at line " + t.beginLine + " column " + t.beginColumn + " is empty");
    }
    sortNameToExpression.put(t.image, (ASTsortExpression) n);
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode sortExpression() :
{/*@bgen(jjtree) sortExpression */
  ASTsortExpression jjtn000 = new ASTsortExpression(JJTSORTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
  String s;
}
{/*@bgen(jjtree) sortExpression */
  try {
/*@egen*/
  LOOKAHEAD(2)
  n = setExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }
| LOOKAHEAD({ (getToken(1) != null && (getToken(1).image) != null) && (constantsMapping.containsKey(getToken(1).image) || isInteger(getToken(1).image)) })
  n = numericRange()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }
| LOOKAHEAD(identifierRange())
  n = identifierRange()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }
| n = concatenation()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

}

SimpleNode setExpression() :
{/*@bgen(jjtree) setExpression */
  ASTsetExpression jjtn000 = new ASTsetExpression(JJTSETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
}
{/*@bgen(jjtree) setExpression */
  try {
/*@egen*/
  n = additiveSetExpression()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode multiplicativeSetExpression() :
{/*@bgen(jjtree) multiplicativeSetExpression */
  ASTmultiplicativeSetExpression jjtn000 = new ASTmultiplicativeSetExpression(JJTMULTIPLICATIVESETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
}
{/*@bgen(jjtree) multiplicativeSetExpression */
  try {
/*@egen*/
  n = unarySetExpression()
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
  }
  (
    < MULT > unarySetExpression()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode additiveSetExpression() :
{/*@bgen(jjtree) additiveSetExpression */
  ASTadditiveSetExpression jjtn000 = new ASTadditiveSetExpression(JJTADDITIVESETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  jjtn000.image = "+";
  SimpleNode n;
}
{/*@bgen(jjtree) additiveSetExpression */
  try {
/*@egen*/
  n = multiplicativeSetExpression()
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
  }
  (
    (
      "+"
      {
        jjtn000.image += "+";
      }
    | "-"
      {
        jjtn000.image += "-";
      }
    )
    multiplicativeSetExpression()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode sortName() :
{/*@bgen(jjtree) sortName */
  ASTsortName jjtn000 = new ASTsortName(JJTSORTNAME);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) sortName */
  try {
/*@egen*/
  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if (!sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("sort " + "#"+ t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
    else
    {
      jjtn000.image = t.image;
      jjtn000.beginLine = t.beginLine;
      jjtn000.beginColumn = t.beginColumn;
    }
    return jjtn000;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode unarySetExpression() :
{/*@bgen(jjtree) unarySetExpression */
  ASTunarySetExpression jjtn000 = new ASTunarySetExpression(JJTUNARYSETEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  SimpleNode n;
}
{/*@bgen(jjtree) unarySetExpression */
  try {
/*@egen*/
  t = < POUND_SIGN > sortName()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return jjtn000;
  }
| n = curlyBrackets()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }
| t = < OP > setExpression() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return jjtn000;
  }

  | n = functionalSymbol()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  {
    if (!FunctionalSymbolChecker.checkFunctionalSymbolSorts((ASTfunctionalSymbol) n, sortNameToExpression))
    {
      throw new ParseException("the definition of record " + n.image + " at line " + n.beginLine + " column " + n.beginColumn + " has a condition which involves " + "checking less/greater relations on elements of non-basic sorts");
    }
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode curlyBrackets() :
{/*@bgen(jjtree) curlyBrackets */
  ASTcurlyBrackets jjtn000 = new ASTcurlyBrackets(JJTCURLYBRACKETS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  SimpleNode child;
}
{/*@bgen(jjtree) curlyBrackets */
  try {
/*@egen*/
  t = < OB > child = constantTermList() < CB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    CurlyBrackets.checkNoKeyWordOccurrences((ASTconstantTermList) child);
    CurlyBrackets.retrieveAllTerms((ASTconstantTermList) child, curlyBracketTerms);
    CurlyBrackets.retrieveAllFunctionalSymbols(jjtn000, definedRecords);
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void concatenationTermList()                   :
{/*@bgen(jjtree) constantTermList */
  ASTconstantTermList jjtn000 = new ASTconstantTermList(JJTCONSTANTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) constantTermList */
  try {
/*@egen*/
  concatenationTerm()
  (
    < COMMA > concatenationTerm()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode constantTermList() :
{/*@bgen(jjtree) constantTermList */
  ASTconstantTermList jjtn000 = new ASTconstantTermList(JJTCONSTANTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) constantTermList */
  try {
/*@egen*/
  (
    constantTerm()
  (
    < COMMA > constantTerm()
  )*)*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void constantTerm():
{/*@bgen(jjtree) constantTerm */
  ASTconstantTerm jjtn000 = new ASTconstantTerm(JJTCONSTANTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t1, t2, t3;
  String s;
}
{/*@bgen(jjtree) constantTerm */
  try {
/*@egen*/
  LOOKAHEAD({ (getToken(1) != null && (getToken(1).image) != null) && (constantsMapping.containsKey(getToken(1).image) || isInteger(getToken(1).image)) })
  t1 = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }
| LOOKAHEAD(2)
  t1 = < IDENTIFIER > t3 = < OP > constantTermList() t2 = < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {  
    jjtn000.image = t1.image + t3.image + " " + t2.image;
  }
| t1 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = t1.beginLine;
    jjtn000.beginColumn = t1.beginColumn;
    jjtn000.image = t1.image;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void concatenationTerm()               :
{/*@bgen(jjtree) constantTerm */
  ASTconstantTerm jjtn000 = new ASTconstantTerm(JJTCONSTANTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t1;
}
{/*@bgen(jjtree) constantTerm */
  try {
/*@egen*/
  LOOKAHEAD({ constantsMapping.containsKey(getToken(1).image) })
  t1 = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }
| t1 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode condition(HashMap < String, Integer > varMap) :
{/*@bgen(jjtree) condition */
  ASTcondition jjtn000 = new ASTcondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t, t1, t2;
}
{/*@bgen(jjtree) condition */
  try {
/*@egen*/
  orCondition(varMap)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void orCondition(HashMap < String, Integer > varMap) :
{/*@bgen(jjtree) orCondition */
  ASTorCondition jjtn000 = new ASTorCondition(JJTORCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) orCondition */
  try {
/*@egen*/
  andCondition(varMap)
  (
    < OR > andCondition(varMap)
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void andCondition(HashMap < String, Integer > varMap) :
{/*@bgen(jjtree) andCondition */
  ASTandCondition jjtn000 = new ASTandCondition(JJTANDCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) andCondition */
  try {
/*@egen*/
  unaryCondition(varMap)
  (
    < AND > unaryCondition(varMap)
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void unaryCondition(HashMap < String, Integer > varMap) :
{/*@bgen(jjtree) unaryCondition */
  ASTunaryCondition jjtn000 = new ASTunaryCondition(JJTUNARYCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t, t3, t4;
}
{/*@bgen(jjtree) unaryCondition */
  try {
/*@egen*/
  t3 = var()
  {
    jjtn000.image = varMap.get(t3.image).toString();
  }
  t = rel()
  {
    jjtn000.image += " " + t.image;
  }
  t4 = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image += " " + varMap.get(t4.image).toString();
  }
| < OP > condition(varMap) < CP >
| t = < NOTOP > condition(varMap) < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode functionalSymbol() :
{/*@bgen(jjtree) functionalSymbol */
  ASTfunctionalSymbol jjtn000 = new ASTfunctionalSymbol(JJTFUNCTIONALSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t1, t2, t3;
  Token from, to;
  HashMap < String, Integer > map;
  HashSet < Integer > BasicSorts;
  SimpleNode c = null;
}
{/*@bgen(jjtree) functionalSymbol */
  try {
/*@egen*/
  t1 = < IDENTIFIER > t3 = < OP >
  {}
  map = specialSortExpressionList() t2 = < CP > [ < COLON > c = condition(map) ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    String recordName = t1.image;
    int arity = jjtn000.jjtGetChild(0).jjtGetNumChildren();
    definedRecords.add(new RecordInfo(recordName,arity)); 
    jjtn000.beginLine = t1.beginLine;
    jjtn000.beginColumn = t1.beginColumn;
    jjtn000.image = t1.image + t3.image + t2.image;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


Token specialSortExpression()       :
{
  Token sortToken,t = null;
}
{
  < POUND_SIGN > sortName() [ < OP > t = < VARIABLE > < CP > ]
  {
    return t;
  }
}

HashMap < String, Integer > specialSortExpressionList()                     :
{/*@bgen(jjtree) sortExpressionList */
  ASTsortExpressionList jjtn000 = new ASTsortExpressionList(JJTSORTEXPRESSIONLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  HashMap < String, Integer > variableMapping = new HashMap < String, Integer > ();
  int agr = 0;
  Token t;
}
{/*@bgen(jjtree) sortExpressionList */
  try {
/*@egen*/
  t = specialSortExpression()
  {
    if (t != null)
    {
      if (variableMapping.containsKey(t.image))
      {
        throw new ParseException("variable " + t.image + " at line " + t.beginLine + ", column " + t.beginColumn + " is used more than once in " + "record definition");
      }
      variableMapping.put(t.image, agr);
    }
    agr++;
  }
  (
    < COMMA > t = specialSortExpression()
    {
      if (t != null)
      {
        if (variableMapping.containsKey(t.image))
        {
          throw new ParseException("variable " + t.image + " at line " + t.beginLine + ", column " + t.beginColumn + " is used more than once in " + "record definition");
        }
        variableMapping.put(t.image, agr);
      }
      agr++;
    }
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return variableMapping;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode concatenation() :
{/*@bgen(jjtree) concatenation */
  ASTconcatenation jjtn000 = new ASTconcatenation(JJTCONCATENATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) concatenation */
  try {
/*@egen*/
  (
    < OSB > basicSort() < OCB >
  )+/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void basicSort() :
{/*@bgen(jjtree) basicSort */
  ASTbasicSort jjtn000 = new ASTbasicSort(JJTBASICSORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode se;
  Token t;
  String s;
}
{/*@bgen(jjtree) basicSort */
  try {
/*@egen*/
  LOOKAHEAD({ (getToken(1) != null && (s = getToken(1).image) != null) && (constantsMapping.containsKey(s) || isInteger(s)) })
  numericRange()
| LOOKAHEAD(identifierRange())
  identifierRange()
| t = < POUND_SIGN > se = sortName()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if (!sortNameToExpression.containsKey(se.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + "#"+ t.image + "' was not defined");
    }
    ASTsortExpression ex = sortNameToExpression.get(se.image);
    if (!BasicSortChecker.isBasic(ex, sortNameToExpression))
    {
      throw new ParseException("ERROR: Sort '" + "#"+ se.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " is not a basic sort");
    }
  }
| concatenationTermList()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


SimpleNode identifierRange() :
{/*@bgen(jjtree) identifierRange */
  ASTidentifierRange jjtn000 = new ASTidentifierRange(JJTIDENTIFIERRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t1, t2;
}
{/*@bgen(jjtree) identifierRange */
  try {
/*@egen*/
  t1 = < IDENTIFIER > < DOT > < DOT > t2 = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    int errorLine = t1.beginLine;
    int errorColumn = t1.beginColumn;
    if (t1.image.length() > t2.image.length())
    {
      throw new ParseException("ERROR: the length of the first identifier in identifier range should be smaller or equal to the length of the second one " + "at line " + errorLine + ", column " + errorColumn);
    }
    if (t1.image.compareTo(t2.image) > 0)
    {
      throw new ParseException("ERROR: the first identifier in identifier range should be lexicographically smaller or equal to  the second one " + "at line " + errorLine + ", column " + errorColumn);
    }
    jjtn000.image = t1.image + " " + t2.image;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode numericRange() :
{/*@bgen(jjtree) numericRange */
  ASTnumericRange jjtn000 = new ASTnumericRange(JJTNUMERICRANGE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token from, to;
}
{/*@bgen(jjtree) numericRange */
  try {
/*@egen*/
  from = number()
  {
    jjtn000.beginLine = from.beginLine;
    jjtn000.beginColumn = from.beginColumn;
  }
  < DOT > < DOT > to = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    int fromI = 0;
    int toI = 0;
    try
    {
      fromI = Integer.parseInt(from.image);
      toI = Integer.parseInt(to.image);
    }
    catch (NumberFormatException ex)
    {}
    if (fromI > toI)
    {
      throw new ParseException("ERROR: the first number in numeric  range should be smaller or equal to  the second one " + "at line " + to.beginLine + ", column " + to.beginColumn);
    }
    jjtn000.image = from.image + " " + to.image;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

Token number()       :
{
  Token t;
}
{
  t = < POSITIVE_INTEGER >
  {
    int integer = Integer.parseInt(t.image);
	if(integer >  BuiltIn.getMaxInt() )
	{
	    throw new ParseException("ERROR: Integer '" + t.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " is out of range");
    }
    return t;
  }
| t = < ZERO >
  {
    return t;
  }
| t = < NONZERODIGIT >
  {
    return t;
  }
| t = < IDENTIFIER >
  {
    if (!constantsMapping.containsKey(t.image))
    {
      throw new ParseException("ERROR: Constant '" + t.image + "' at line " + t.beginLine + ", column " + t.beginColumn + " was not defined");
      //return t;
    }
    else
    {
      t.image = constantsMapping.get(t.image).toString();
      return t;
    }
  }
}

void predicateDeclarations() :
{/*@bgen(jjtree) predicateDeclarations */
  ASTpredicateDeclarations jjtn000 = new ASTpredicateDeclarations(JJTPREDICATEDECLARATIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) predicateDeclarations */
  try {
/*@egen*/
  < PREDDEFKEYWORD >
  (
    predicateDeclaration()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    HashSet < String > usedPredicateNames = new HashSet < String > ();
    usedPredicateNames.addAll(predicateArgumentSorts.keySet());
    
    for (String sortName : sortNameToExpression.keySet())
    {
      predicateArgumentSorts.put("#" + sortName, new ArrayList < String > ());
      predicateArgumentSorts.get("#" + sortName).add(sortName);
      String nameCandidate = sortName;
      while (usedPredicateNames.contains(nameCandidate))
      {
        nameCandidate += "_";
      }
      usedPredicateNames.add(nameCandidate);
      sortRenaming.put(sortName, nameCandidate);  
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void predicateDeclaration() :
{/*@bgen(jjtree) predicateDeclaration */
  ASTpredicateDeclaration jjtn000 = new ASTpredicateDeclaration(JJTPREDICATEDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  ArrayList < String > arguments = new ArrayList < String > ();
}
{/*@bgen(jjtree) predicateDeclaration */
  try {
/*@egen*/
  t = < IDENTIFIER >
  {
    if (predicateArgumentSorts.containsKey(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "predicate " + t.image + " was already declared");
    }
    if (BuiltInPredicates.predicateNamesSet.contains(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "predicate " + t.image + " is a built-in predicate");
    }
  }
  < OP >
  (
    arguments = identifierList()
  )?
  {
    predicateArgumentSorts.put(t.image, arguments);
  }
  < CP > < DOT >/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

ArrayList < String > identifierList() :
{/*@bgen(jjtree) identifierList */
  ASTidentifierList jjtn000 = new ASTidentifierList(JJTIDENTIFIERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  ArrayList < String > result = new ArrayList < String > ();
  Token t;
}
{/*@bgen(jjtree) identifierList */
  try {
/*@egen*/
  
  (
    < POUND_SIGN > t = < IDENTIFIER >
  {
    if (!sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + "#"+ t.image + "' was not defined");
    }
    result.add(t.image);
  }
  (
    < COMMA > < POUND_SIGN > t = < IDENTIFIER >
    {
     if (!sortNameToExpression.containsKey(t.image))
    {
      throw new ParseException("Line " + t.beginLine + ", column " + t.beginColumn + ": " + "sort '" + "#" + t.image + "' was not defined");
    }
      result.add(t.image);
    }
  )*)/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return result;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode programRules() :
{/*@bgen(jjtree) programRules */
  ASTprogramRules jjtn000 = new ASTprogramRules(JJTPROGRAMRULES);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) programRules */
  try {
/*@egen*/
  < PROGRULDEFKEYWORD >
  (
    programRule()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode programRule() :
{/*@bgen(jjtree) programRule */
  ASTprogramRule jjtn000 = new ASTprogramRule(JJTPROGRAMRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  SimpleNode n;
  inHead = true;
}
{/*@bgen(jjtree) programRule */
  try {
/*@egen*/
  LOOKAHEAD(2)
  t = label()
  {
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    jjtn000.setLabel(t.image);
    if (crRuleLabels.contains(t.image))
    {
      throw new ParseException("cr-rule label " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " occures more then once");
    }
    else
    {
      crRuleLabels.add(t.image);
    }
  }
  n = unlabeledProgramCrRule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }
| n = unlabeledProgramRule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode unlabeledProgramRule() :
{/*@bgen(jjtree) unlabeledProgramRule */
  ASTunlabeledProgramRule jjtn000 = new ASTunlabeledProgramRule(JJTUNLABELEDPROGRAMRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Pair n;
  SimpleNode n2;
  Token from, to, sep;
}
{/*@bgen(jjtree) unlabeledProgramRule */
  try {
/*@egen*/
  LOOKAHEAD(predSymbol() number() < DOT >)
  n = predSymbol() from = number() < DOT > < DOT > to = number() < CP > < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ //can be body here after safety fix!
  {
    jjtn000.beginLine = n.first.beginLine;
    jjtn000.beginColumn = n.first.beginColumn;
    jjtn000.image = n.first.image + " " + from.image + " " + to.image;
    inHead = false;
    return jjtn000;
  }
| n2 = head()
  {
    inHead = false;
  }
  sep = exBody()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = sep.image;
    jjtn000.beginLine = n2.beginLine;
    jjtn000.beginColumn = n2.beginColumn;
    return jjtn000;
  }
| sep = < ORRSEP >
  {
    inHead = false;
    jjtn000.image = sep.image;
    jjtn000.beginLine = sep.beginLine;
    jjtn000.beginColumn = sep.beginColumn;
  }
  body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }
| sep = < CRRSEP >
  {
    inHead = false;
    jjtn000.beginLine = sep.beginLine;
    jjtn000.beginColumn = sep.beginColumn;
    jjtn000.image = sep.image;
  }
  body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }
| sep = < WEAKSEP >
  {
    inHead = false;
    jjtn000.beginLine = sep.beginLine;
    jjtn000.beginColumn = sep.beginColumn;
    jjtn000.image = sep.image;
  }
  body() < DOT > [ constraintParams() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void constraintParams() :
{/*@bgen(jjtree) constraintParams */
  ASTconstraintParams jjtn000 = new ASTconstraintParams(JJTCONSTRAINTPARAMS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t0;
  Token t1 = null, t2 = null, t3 = null, t4 = null, t5 = null;
  jjtn000.image = "";
}
{/*@bgen(jjtree) constraintParams */
  try {
/*@egen*/
  t0 = < OSB >
  [
    (
      t1 = var()
    | t2 = number()
    )
  ]
  t5 = < COLON >
  [
    (
      t3 = var()
    | t4 = number()
    )
  ]
  < OCB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if (t1 == null && t2 == null && t3 == null && t4 == null)
    {
      throw new ParseException("line " + t0.beginLine + ", column " + t0.beginColumn + ": weak constraint paramethers cannot both be empty");
    }
    if (t2 != null)
    {
      jjtn000.image += t2.image;
    }
    else if (t1 != null)
    {
      jjtn000.image += "V";
    }
    jjtn000.image += t5.image;
    if (t4 != null)
    {
      jjtn000.image += t4.image;
    }
    else if (t3 != null)
    {
      jjtn000.image += "V";
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode unlabeledProgramCrRule() :
{/*@bgen(jjtree) unlabeledProgramCrRule */
  ASTunlabeledProgramCrRule jjtn000 = new ASTunlabeledProgramCrRule(JJTUNLABELEDPROGRAMCRRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
  Token t;
}
{/*@bgen(jjtree) unlabeledProgramCrRule */
  try {
/*@egen*/
  n = head() t = exCrBody()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    jjtn000.image = t.image;
    return jjtn000;
  }
| t = < CRRSEP > body() < DOT >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    jjtn000.image = t.image;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

Token label()       :
{
  Token t;
}
{
  t = < IDENTIFIER > < COLON >
  {
    return t;
  }
}

Token exBody()       :
{
  Token t;
}
{
  t = exStandartBody()
  {
    return t;
  }
| t = exCrBody()
  {
    return t;
  }
}

Token exStandartBody()       :
{
  Token t;
}
{
  t = < ORRSEP > body() < DOT >
  {
    return t;
  }
| t = < DOT >
  {
    return new Token(SparcTranslatorConstants.ORRSEP, ":-");
  }
}

Token exCrBody()       :
{
  Token t;
}
{
  t = < CRRSEP > crBodyWithoutSep()
  {
    return t;
  }
}

void crBodyWithoutSep()       :
{}
{
  < DOT >
| body() < DOT >
}

SimpleNode head() :
{/*@bgen(jjtree) head */
  ASThead jjtn000 = new ASThead(JJTHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
}
{/*@bgen(jjtree) head */
  try {
/*@egen*/
  LOOKAHEAD(2)
  n = choice_rule()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }
| n = disjunction()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }
| n = optimize_statement()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
        
SimpleNode optimize_statement() :
{/*@bgen(jjtree) optimize_statement */
  ASToptimize_statement jjtn000 = new ASToptimize_statement(JJTOPTIMIZE_STATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) optimize_statement */
  try {
/*@egen*/
  t = optimize_ob() [ optimizeParameterList() ] < COLON > [ nonRelAtomList() ] < CB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  { 
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    if (Settings.getSingletonInstance().getSolver() != ASPSolver.Clingo) 
        throw new ParseException("line " + jjtn000.beginLine + ", column " + jjtn000.beginColumn + ": optimization statements are not supported in DLV");
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

Token optimize_ob()       :
{
  Token t;
}
{
  t = < MINIMIZE_OB >
  {
    return t;
  }
| t = < MAXIMIZE_OB >
  {
    return t;
  }
}

void optimizeParameterList() :
{/*@bgen(jjtree) optimizeParameterList */
  ASToptimizeParameterList jjtn000 = new ASToptimizeParameterList(JJTOPTIMIZEPARAMETERLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) optimizeParameterList */
    try {
/*@egen*/
    optimizeParameter()
    (
    < COMMA > optimizeParameter()
    )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void nonRelAtomList() :
{/*@bgen(jjtree) nonRelAtomList */
  ASTnonRelAtomList jjtn000 = new ASTnonRelAtomList(JJTNONRELATOMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) nonRelAtomList */
    try {
/*@egen*/
    nonRelAtom()
    (
    < COMMA > nonRelAtom()
    )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
        
void optimizeParameter() :
{/*@bgen(jjtree) optimizeParameter */
    ASToptimizeParameter jjtn000 = new ASToptimizeParameter(JJTOPTIMIZEPARAMETER);
    boolean jjtc000 = true;
    jjtree.openNodeScope(jjtn000);
/*@egen*/
    Token t1, t2, t3;
    jjtn000.image = "";
}
{/*@bgen(jjtree) optimizeParameter */
  try {
/*@egen*/
  LOOKAHEAD(var() < AT > number())
  t1 = var() t2 = <AT> t3 = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image + t2.image + t3.image; 
  }
| LOOKAHEAD(number() < AT > number())
  t1 = number() t2 = <AT> t3 = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image + t2.image + t3.image;
  }
| LOOKAHEAD(var())
  t1 = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }
| LOOKAHEAD(number())
  t1 = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode disjunction() :
{/*@bgen(jjtree) disjunction */
  ASTdisjunction jjtn000 = new ASTdisjunction(JJTDISJUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
}
{/*@bgen(jjtree) disjunction */
  try {
/*@egen*/
  n = nonRelAtom()
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
  }
  (
    < HEAD_OR > nonRelAtom()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode choice_rule() :
{/*@bgen(jjtree) choice_rule */
  ASTchoice_rule jjtn000 = new ASTchoice_rule(JJTCHOICE_RULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n1 = null;
  Token t;
}
{/*@bgen(jjtree) choice_rule */
  try {
/*@egen*/
  [
    n1 = arithmeticTerm()
    [
      t = rel()
      {
        jjtn000.image = "L" + t.image;
      }
    ]
  ]
  t = < OB > choice_elements() < CB >
  [
    [
      t = rel()
      {
        jjtn000.image += " R" + t.image;
      }
    ]
    arithmeticTerm()
  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if (n1 != null)
    {
      jjtn000.beginLine = n1.beginLine;
      jjtn000.beginColumn = n1.beginColumn;
    }
    else
    {
      jjtn000.beginLine = t.beginLine;
      jjtn000.beginColumn = t.beginColumn;
    }
    if (Settings.getSingletonInstance().getSolver() != ASPSolver.Clingo) 
    throw new ParseException("line " + jjtn000.beginLine + ", column " + jjtn000.beginColumn + ": choice rules are not supported in DLV");
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void choice_elements() :
{/*@bgen(jjtree) choice_elements */
  ASTchoice_elements jjtn000 = new ASTchoice_elements(JJTCHOICE_ELEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) choice_elements */
  try {
/*@egen*/
  choice_element()
  (
    < SEMICOLON > choice_element()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void choice_element() :
{/*@bgen(jjtree) choice_element */
  ASTchoice_element jjtn000 = new ASTchoice_element(JJTCHOICE_ELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
}
{/*@bgen(jjtree) choice_element */
  try {
/*@egen*/
  n = nonRelAtom() [ < COLON > extendedSimpleAtomList() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void extendedSimpleAtomList() :
{/*@bgen(jjtree) extendedSimpleAtomList */
  ASTextendedSimpleAtomList jjtn000 = new ASTextendedSimpleAtomList(JJTEXTENDEDSIMPLEATOMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) extendedSimpleAtomList */
  try {
/*@egen*/
  simpleAtom()
  (
    < COMMA > simpleAtom()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void body() :
{/*@bgen(jjtree) body */
  ASTbody jjtn000 = new ASTbody(JJTBODY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) body */
  try {
/*@egen*/
  atom()
  (
    < COMMA > atom()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

Token var() :
{/*@bgen(jjtree) var */
  ASTvar jjtn000 = new ASTvar(JJTVAR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) var */
  try {
/*@egen*/
  t = < VARIABLE >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
    jjtn000.setOriginalImage(t.image);
    return t;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode nonRelAtom() :
{/*@bgen(jjtree) nonRelAtom */
  ASTnonRelAtom jjtn000 = new ASTnonRelAtom(JJTNONRELATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode tList = null;
  Pair n;
}
{/*@bgen(jjtree) nonRelAtom */
  try {
/*@egen*/
  n = predSymbol()
  {
    jjtn000.beginLine = n.first.beginLine;
    jjtn000.beginColumn = n.first.beginColumn;
  }
  [
    tList = termList()
    {
      if (!n.second && tList != null)
      {
        throw new ParseException("ERROR:( expected at line " + tList.beginLine + " column " + tList.beginColumn);
      }
    }
    < CP >
  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    ASTpredSymbol predS = (ASTpredSymbol) n.first;
    if (predS.hasPoundSign && (tList == null || tList.jjtGetNumChildren() != 1) && !inDisplay)
    {
      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " must have exactly one argument");
    }

    if (predS.hasPoundSign && tList != null && tList.jjtGetNumChildren() > 1 && inDisplay)
    {
      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " cannot have more than one argument");
    }

    
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void simpleAtom() :
{/*@bgen(jjtree) simpleAtom */
  ASTsimpleAtom jjtn000 = new ASTsimpleAtom(JJTSIMPLEATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
  Token t;
}
{/*@bgen(jjtree) simpleAtom */
  try {
/*@egen*/
  LOOKAHEAD(symbolicTerm() rel() symbolicTerm())
  symbolicTerm() t = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }
| LOOKAHEAD(symbolicTerm() rel() var())
  symbolicTerm() t = rel() var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }
| LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())
  arithmeticTerm() t = rel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }
| LOOKAHEAD(var() rel() symbolicTerm())
  var() t = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }
| LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())
  arithmeticTerm() t = eqrel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }
| LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())
  symbolicTerm() t = eqrel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }
| n = extendedNonRelAtom()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = n.image;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode extendedNonRelAtom() :
{/*@bgen(jjtree) extendedNonRelAtom */
  ASTextendedNonRelAtom jjtn000 = new ASTextendedNonRelAtom(JJTEXTENDEDNONRELATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
  jjtn000.image = "";
  SimpleNode tList = null;
  Pair n;
}
{/*@bgen(jjtree) extendedNonRelAtom */
  try {
/*@egen*/
  [
    t = < NOT >
    {
      jjtn000.image = t.image;
    }
  ]
  n = predSymbol()
  [
    tList = termList()
    {
      if (!n.second && tList != null)
      {
        throw new ParseException("ERROR:( expected at line " + tList.beginLine + " column " + tList.beginColumn);
      }
    }
    < CP >
  ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    ASTpredSymbol predS = (ASTpredSymbol) n.first;
    if (predS.hasPoundSign && (tList == null || tList.jjtGetNumChildren() != 1))
    {
      throw new ParseException("sort predicate " + n.first.image + " at line " + n.first.beginLine + " column " + n.first.beginColumn + " must have exactly one argument");
    }
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode addOp()       :
{
  Token t;
  SimpleNode n = new SimpleNode(0);
}
{
  t = < PLUS >
  {
    n.image = t.image;
    return n;
  }
| t = < MINUS >
  {
    n.image = t.image;
    return n;
  }
}

SimpleNode multOp()       :
{
  Token t;
  SimpleNode n = new SimpleNode(0);
}
{
  t = < MULT >
  {
    n.image = t.image;
    return n;
  }
| t = < DIV >
  {
    n.image = t.image;
    return n;
  }
}

SimpleNode arithmeticTerm() :
{/*@bgen(jjtree) arithmeticTerm */
  ASTarithmeticTerm jjtn000 = new ASTarithmeticTerm(JJTARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
}
{/*@bgen(jjtree) arithmeticTerm */
  try {
/*@egen*/
  n = additiveArithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode atomicArithmeticTerm() :
{/*@bgen(jjtree) atomicArithmeticTerm */
  ASTatomicArithmeticTerm jjtn000 = new ASTatomicArithmeticTerm(JJTATOMICARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
 
}
{/*@bgen(jjtree) atomicArithmeticTerm */
  try {
/*@egen*/
  
  LOOKAHEAD({  (getToken(1) != null && getToken(1).image != null) && (constantsMapping.containsKey(getToken(1).image ) || isInteger(getToken(1).image )) })
  t = number()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return jjtn000;
  }
| t = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return jjtn000;
  }
| t = < OP > arithmeticTerm() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode additiveArithmeticTerm() :
{/*@bgen(jjtree) additiveArithmeticTerm */
  ASTadditiveArithmeticTerm jjtn000 = new ASTadditiveArithmeticTerm(JJTADDITIVEARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
  jjtn000.image = "+";
}
{/*@bgen(jjtree) additiveArithmeticTerm */
  try {
/*@egen*/
  n = multiplicativeArithmeticTerm()
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
  }
  (
    n = addOp()
    {
      jjtn000.image += n.image;
    }
    multiplicativeArithmeticTerm()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode multiplicativeArithmeticTerm() :
{/*@bgen(jjtree) multiplicativeArithmeticTerm */
  ASTmultiplicativeArithmeticTerm jjtn000 = new ASTmultiplicativeArithmeticTerm(JJTMULTIPLICATIVEARITHMETICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
  jjtn000.image = "";
}
{/*@bgen(jjtree) multiplicativeArithmeticTerm */
  try {
/*@egen*/
  n = atomicArithmeticTerm()
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
  }
  (
    n = multOp()
    {
      jjtn000.image += n.image;
    }
    atomicArithmeticTerm()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode symbolicFunction() :
{/*@bgen(jjtree) symbolicFunction */
  ASTsymbolicFunction jjtn000 = new ASTsymbolicFunction(JJTSYMBOLICFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) symbolicFunction */
  try {
/*@egen*/
  t = < IDENTIFIER_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
    jjtn000.beginColumn = t.beginColumn;
    jjtn000.beginLine = t.beginLine;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


SimpleNode symbolicConstant() :
{/*@bgen(jjtree) symbolicConstant */
  ASTsymbolicConstant jjtn000 = new ASTsymbolicConstant(JJTSYMBOLICCONSTANT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) symbolicConstant */
  try {
/*@egen*/
  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode symbolicTerm() :
{/*@bgen(jjtree) symbolicTerm */
  ASTsymbolicTerm jjtn000 = new ASTsymbolicTerm(JJTSYMBOLICTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
}
{/*@bgen(jjtree) symbolicTerm */
  try {
/*@egen*/
  n = symbolicConstant()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }
| n = symbolicFunction()
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
  }
  termList() < CP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

SimpleNode term() :
{/*@bgen(jjtree) term */
  ASTterm jjtn000 = new ASTterm(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
  Token t;
  jjtn000.image = "";
}
{/*@bgen(jjtree) term */
 try {
/*@egen*/

 LOOKAHEAD(var() (< CP >
| < COMMA > | < COLON >))
  t = var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    //System.out.println("t.image");
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return jjtn000;
  }
| 
  LOOKAHEAD(2)
  n = arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }
| n = symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
    return jjtn000;
  }/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof RuntimeException) {
     throw (RuntimeException)jjte000;
   }
   if (jjte000 instanceof ParseException) {
     throw (ParseException)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
   }
 }
/*@egen*/
}

SimpleNode termList() :
{/*@bgen(jjtree) termList */
  ASTtermList jjtn000 = new ASTtermList(JJTTERMLIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode t;
}
{/*@bgen(jjtree) termList */
  try {
/*@egen*/
  t = term()
  {
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
  }
  (
    < COMMA > term()
  )*/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    return jjtn000;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

Token rel()       :
{
  Token t;
}
{
  t = < EQ >
  {
    return t;
  }
| t = < NOTEQ >
  {
    return t;
  }
| t = < GT >
  {
    return t;
  }
| t = < GTEQ >
  {
    return t;
  }
| t = < SM >
  {
    return t;
  }
| t = < SMEQ >
  {
    return t;
  }
| t = < EQR >
  {
    return t;
  }
}

Token eqrel()       :
{
  Token t;
}
{
  t = < EQ >
  {
    return t;
  }
| t = < NOTEQ >
  {
    return t;
  }
}

Pair predSymbol() :
{/*@bgen(jjtree) predSymbol */
  ASTpredSymbol jjtn000 = new ASTpredSymbol(JJTPREDSYMBOL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t, poundSign = null;
}
{/*@bgen(jjtree) predSymbol */
  try {
/*@egen*/
  t = < IDENTIFIER >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, false);
  }
| t = < IDENTIFIER_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image.substring(0, t.image.length() - 1);
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, true);
  }

| 
t = < SORT_ATOM_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setPoundSign(true);
    if (inHead)
    
    {
      throw new ParseException("sort name " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
    }
    String sort = t.image.substring(0, t.image.length() - 1);
    if (!predicateArgumentSorts.containsKey(sort))
    {
      throw new ParseException("sort " + t.image.substring(0, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
    generatingSorts.add(t.image.substring(1, t.image.length()-1));
    jjtn000.image = t.image.substring(1, t.image.length() - 1);
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, true);
  }

| t = < NEGATIVE_ATOM_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.negative = true;
    jjtn000.image = t.image.substring(1, t.image.length() - 1);
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, true);
  }
| t = < NEGATIVE_ATOM >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.negative = true;
    jjtn000.image = t.image.substring(1, t.image.length());
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, false);
  }
| t = < NEGATIVE_SORT_ATOM_WITH_OP >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setPoundSign(true);
    if (inHead)
    {
      throw new ParseException("sort name " + t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
    }
    sort = t.image.substring(2, t.image.length() - 1);
    if (!predicateArgumentSorts.containsKey(sort))
    {
      throw new ParseException("sort " +  t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
   
    jjtn000.negative = true;
    jjtn000.image = t.image.substring(2, t.image.length() - 1);
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, true);
  }

  | t = < SORT_ATOM >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setPoundSign(true);
    if (inHead)
    {
      throw new ParseException("sort name " + t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
    }
    sort = t.image;
    if (!predicateArgumentSorts.containsKey(sort))
    {
      throw new ParseException("sort " + t.image + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
    generatingSorts.add(t.image.substring(1));
    jjtn000.negative = false;
    jjtn000.image = t.image.substring(1);
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, false);
  }

  | t = < NEGATIVE_SORT_ATOM >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.setPoundSign(true);
    if (inHead)
    {
      throw new ParseException("sort name " + t.image.substring(1, t.image.length() - 1) + " at line " + t.beginLine + " column " + t.beginColumn + " cannot occur in the head");
    }
    sort = t.image.substring(2);
    if (!predicateArgumentSorts.containsKey(sort))
    {
      throw new ParseException("sort " + t.image.substring(1) + " at line " + t.beginLine + " column " + t.beginColumn + " was not defined");
    }
    jjtn000.negative = true;
    jjtn000.image = t.image.substring(2);
    jjtn000.beginLine = t.beginLine;
    jjtn000.beginColumn = t.beginColumn;
    return new Pair(jjtn000, false);
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/

  
}

void atom() :
{/*@bgen(jjtree) atom */
  ASTatom jjtn000 = new ASTatom(JJTATOM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t1;
}
{/*@bgen(jjtree) atom */
  try {
/*@egen*/
  LOOKAHEAD([ arithmeticTerm() rel() ] aggregateFunction())
  aggregate()
| LOOKAHEAD(symbolicTerm() rel() symbolicTerm())
  symbolicTerm() t1 = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }
| LOOKAHEAD(symbolicTerm() rel() var())
  symbolicTerm() t1 = rel() var()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }
| LOOKAHEAD(var() rel() symbolicTerm())
  var() t1 = rel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }
| LOOKAHEAD(arithmeticTerm() eqrel() symbolicTerm())
  arithmeticTerm() t1 = eqrel() symbolicTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }
| LOOKAHEAD(symbolicTerm() eqrel() arithmeticTerm())
  symbolicTerm() t1 = eqrel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }
| LOOKAHEAD(arithmeticTerm() rel() arithmeticTerm())
  arithmeticTerm() t1 = rel() arithmeticTerm()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t1.image;
  }
| extendedNonRelAtom()/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void aggregate() :
{/*@bgen(jjtree) aggregate */
  ASTaggregate jjtn000 = new ASTaggregate(JJTAGGREGATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t1 = null, t2 = null;
  jjtn000.image = "";
}
{/*@bgen(jjtree) aggregate */
  try {
/*@egen*/
  [ arithmeticTerm() t1 = rel() ] aggregateFunction() aggregateElements() < CB > [ t2 = rel() arithmeticTerm() ]/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    if (t1 != null)
    {
      jjtn000.image += "L" + t1.image;
    }
    if (t2 != null)
    {
      jjtn000.image += "R" + t2.image;
    }
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void aggregateElements() :
{/*@bgen(jjtree) aggregateElements */
  ASTaggregateElements jjtn000 = new ASTaggregateElements(JJTAGGREGATEELEMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) aggregateElements */
  try {
/*@egen*/
  aggregateElement()
  (
    < SEMICOLON > aggregateElement()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void aggregateElement():
{/*@bgen(jjtree) aggregateElement */
  ASTaggregateElement jjtn000 = new ASTaggregateElement(JJTAGGREGATEELEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  SimpleNode n;
}
{/*@bgen(jjtree) aggregateElement */
  try {
/*@egen*/
  (
    n = term()
  )
  (
    < COMMA >
      term()
  )*
   < COLON > extendedSimpleAtomList()/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/ 
  {
    for(int i=0; i<jjtn000.jjtGetNumChildren(); i++)
    {
        SimpleNode child = (SimpleNode) jjtn000.jjtGetChild(i);
        if(child.getId() == SparcTranslatorTreeConstants.JJTTERM)
        {
           ASTterm term = (ASTterm) child;
           if(!term.isGround() && !term.isVariable())
           {
             throw new ParseException("the term at line " + n.beginLine + " column " + n.beginColumn + " is not ground and is not a variable ");
           }
        }
    }
    jjtn000.beginLine = n.beginLine;
    jjtn000.beginColumn = n.beginColumn;
  }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void aggregateFunction() :
{/*@bgen(jjtree) aggregateFunction */
  ASTaggregateFunction jjtn000 = new ASTaggregateFunction(JJTAGGREGATEFUNCTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  Token t;
}
{/*@bgen(jjtree) aggregateFunction */
  try {
/*@egen*/
  t = < AGGREGATE_COUNT_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }
| t = < AGGREGATE_MAX_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }
| t = < AGGREGATE_MIN_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }
| t = < AGGREGATE_SUM_OB >/*@bgen(jjtree)*/
  {
    jjtree.closeNodeScope(jjtn000, true);
    jjtc000 = false;
  }
/*@egen*/
  {
    jjtn000.image = t.image;
  }/*@bgen(jjtree)*/
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}

void atomSequence() :
{/*@bgen(jjtree) atomSequence */
  ASTatomSequence jjtn000 = new ASTatomSequence(JJTATOMSEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) atomSequence */
  try {
/*@egen*/
  atom()
  (
    < COMMA > atom()
  )*/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}


void directives(ArrayList < String > directives)       :
{}
{
  (
    directive(directives)
  )*
  {
    addBuiltInSorts();
  }
}

void directive(ArrayList < String > directives)       :
{
  Token t, t1, t2, t3, t4;
}
{
  t = < MAXINTDIRECTIVE > t1 = < EQ > t2 = number() t3 = < DOT >
  {
    Integer value = Integer.parseInt(t2.image);
    BuiltIn.setMaxInt(value);
  }
| t = < CONSTDIRECTIVE > t1 = < IDENTIFIER > t2 = < EQ > t3 = number() t4 = < DOT >
  {
    directives.add(t.image + " " + t1.image + t2.image + t3.image + t4.image);
    constantsMapping.put(t1.image, Long.parseLong(t3.image));
  }
}

SimpleNode display():
{/*@bgen(jjtree) display */
  ASTdisplay jjtn000 = new ASTdisplay(JJTDISPLAY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/
  inDisplay = true;
}
{/*@bgen(jjtree) display */
  try {
/*@egen*/
  < DISPLAYKEYWORD >
    (
      nonRelAtom() < DOT >
    )*/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
      return jjtn000;
    }/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/
}
